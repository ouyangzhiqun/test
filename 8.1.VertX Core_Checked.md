## Vert.x开发笔记【`Java`版】

`3.0`的模块支持清单：

* <font style="color:blue">**`Core`**</font>
* `Web`
* `Data access`
	* `MongoDB Client`
	* `JDBC Client`
	* `SQL common`
	* `Redis client`
* `Integration`
	* `Main Client`
	* `JCA Adaptor`
* `Authentication & Authorisation`
	* `Auth Common`
	* `JDBC Auth`
	* `JWT Auth`
	* `Shiro Auth`
* `Reactive`
	* `Vert.X Rx`
	* `Reactive streams`
* `Metrics`
* `Testing`
* `Clustering`
	* `Hazelcast`
* `Services`
	* `Service Factories`
	* `Service Proxies`
	* `Maven Service Factory`
	* `HTTP Service Factory`
* `Cloud and Docker`
	* `Vert.X OpenShift Cartridge`
	* `Vert.X OpenShift Using DIY Cartridge`
	* `Vert.X Docker Images`
* `Advanced`
	* `Codegen`
	* `Docgen`
	* `Codetrans`
	* `Distro`
	* `Web-Site`
<hr/>


<font style="color:red">*: TCP、HTTP、UDP服务器以及客户端的书写部分省略，暂时不翻译，省略话题如下：

* Writing TCP Servers and Clients
* Writing HTTP Servers and Clients
* Datagram Sockets ( UDP )
* DNS Client
* Streams
* Record Parser
* Thread Safety
* Metrics SPI
* OSGI
* Security Nodes

</font>

<hr/>

### Vert.X Core【`Manual`】

### 1.功能表

* 书写`TCP`客户端和服务端
* 书写支持`WebSockets`的HTTP客户端和服务端
* `Event Bus`
* 数据共享——本地哈希表和集群分布式哈希表共享
* 预测以及延迟行为【`Periodic/Delayed`】
* `Verticle`的发布以及卸载【`Deploying/Undeploying`】
* 基于`Socket`的数据包
* `DNS`客户端
* 访问文件系统`File System`
* 高可用性：`High availability`
* 集群支持：`Cluster`

<hr/>

### 2.`Vert.X`对象

嵌入一个`Vertx`对象，并且创建一个`Vertx`的实例【`Instance`】：

	Vertx vertx = Vertx.vertx();
_NOTE：大部分应用仅仅需要一个`Vert.x`实例，但是如果有必要可以创建多个`Vert.x`实例，比如需要共享`Event Bus`以及使用不同的客户端和服务端组。_

为嵌入的`Vertx`提供配置选项的方式：

	Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));
`VertxOptions`对象包含了各种`Vertx`需要的配置项，例如集群、高可用、池空间等。

<hr/>

### 3.`Fluent`的API

`Vertx`支持两种方式的API调用

**`Fluent`模式**

	request.response().putHeader("Content-Type", "text/plain").write("some text").end();
**`Non-Fluent`模式**

	HttpServerResponse response = request.response();
	response.putHeader("Content-Type", "text/plain");
	response.write("some text");
	response.end();

<hr/>

### 4.异步调用

`Vert.X`的API是大型事件驱动API【`Event Driven`】，它会通过发送事件的方式主动调用程序，而不是等待请求，事件如：

* 启用计时器【`Timer`】
* 通过`Socket`接受数据
* 直接从磁盘读取数据
* 异常发生
* 一个`HTTP`服务器接受请求

计时器例子

	vertx.setPeriodic(1000, id -> {
		// This handler will get called every second
		System.out.println("timer fired!");
	});
接受`HTTP`请求例子

	server.requestHandler(request -> {
		// This handler will be called every time an HTTP request is received at the server
		request.response().end("hello world!");
	});
<font style="color:red">核心概念：VertX的调用都是异步调用【`Asynchronously`】</font>

<hr/>

### 5.`Reactor`模式

`VertX`在调用程序时使用了名为`Event Loop`的线程，因为是基于非阻塞的`Reactor`设计模式【`Node.js`的实现模式】，所以在调用的时候针对同步方式【`Block Calling`】需要斟酌，同步的行为包括：

* 从`Socket`读取数据
* 写入数据到磁盘
* 发送请求以及等待相应
* 其他情况

标准的`Reactor`实现方式及基于单个事件循坏【`Single Event Loop`】，但是单个事件循坏导致的问题是在同一个时间中单个线程仅仅只能运行在单个核里，而`VertX`在这个模式中进行了提炼，每一个`Vert.X`的实例都维护了许多事件循坏队列【`Several Event Loop`】，默认情况下会根据机器的CPU的核数量来实现`Reactor`，这种模式称为：多路`Rector`模式【`Multi-Reactor Pattern`】。

### <font style="color:red">黄金法则：`Don't Block the Event Loop`</font>

因为`VertX`的API都是非阻塞异步模式，如果有需要实现阻塞同步调用的时候需要使用`VertX`提供的方式，而不是手动去实现，这个规则很重要，如果不遵循会引起系统的卡死，手动实现包括：

* `Thread.sleep()`
* 写一个锁`Lock`
* 写一个`Mutex`或者`Monitor`【一个同步块——`Synchorinzed`】
* 写一个访问时间很长的数据库访问操作并且等待结果
* 在一个有效时间内执行很复杂的运算
* 编写一个比较大的循环【`Loop`】

**significant amount of time**：整个事件循环队列执行的时间总和，调试`VertX`程序时可通过`VertxOptions`打开警告信息，则出现`Block`的时候可以看到下边类型日志：

	Thread vertx-eventloop-thread-3 has been blocked for 20458 ms

<hr/>

### 6.`Blocking Code`

阻塞同步方式的代码在某些情况下是不可避免的，如果需要实现`VertX`中的`Blocking Code`有两种方式：

**使用内联方法`executeBlocking`**

	vertx.executeBlocking(future -> {
		// Call some blocking API that takes a significant amount of time to return
		String result = someAPI.blockingMethod("hello");
		future.complete(result);
	}, res -> {
		System.out.println("The result is: " + res.result());
	});
默认情况下`Block`部分的代码会在`Context`或`Verticle`实例中依次执行，如果不关心这些代码的执行顺序则可以将`ordered`参数设置成`false`。

**使用`Worker Verticle`**

更简单的一种方式是使用`Worker`类型的`Verticle`来调用`Blocking Code`，这个实例通常会在一个`Worker`线程池中的某个线程内执行。

<hr/>

### 7.书写`Verticle`

书写`Verticle`通常有两种方式：

* `Verticle`类必须实现接口`Verticle`；
* `VertX`中还提供了抽象类`AbstractVerticle`，也可以直接从这个类中继承过来；

下边是一个简单的`Verticle`的例子：

	public class MyVerticle extends AbstractVerticle {

		// Called when verticle is deployed
		public void start() {
		}

		// Optional - called when verticle is undeployed
		public void stop() {
		}
	}

* **start**：该方法会在`Deploy`这个`Verticle`的时候调用；
* **stop**：该方法会在`Undeploy`这个`Verticle`的时候调用；

实现异步模式的`start`和`stop`，`VertX`实例的发布和卸载可以实现一个异步的版本，而这种实现是不会破坏上边的黄金法则【`Golden Rule`】的。

异步版本的`start`方法

	public class MyVerticle extends AbstractVerticle {

		public void start(Future<Void> startFuture) {
			// Now deploy some other verticle:
			vertx.deployVerticle("com.foo.OtherVerticle", res -> {
				if (res.succeeded()) {
					startFuture.complete();
				} else {
					startFuture.fail();
				}
			});
		}
	}
异步版本的`stop`方法

	public class MyVerticle extends AbstractVerticle {

		public void start() {
			// Do something
		}

		public void stop(Future<Void> startFuture) {
			obj.doSomethingThatTakesTime(res -> {
				if (res.succeeded()) {
					startFuture.complete();
				} else {
					startFuture.fail();
				}
			});
		}
	}

<font style="color:red">在针对`Verticle`执行发布和卸载【`Deploy && Undeploy`】的操作时，所有子`Verticle`不需要手动发布，在发布父`Verticle`时它对应的子`Verticle`也会同时执行发布和卸载的动作。</font>

<hr/>

### 8.`Verticle`类型
`VertX`中包含了三种不同的`Verticle`：

#### 8.1.`Standard Verticles`
标准的`Verticle`在它被创建过后调用`start`方法时会被赋予一个事件循环线程【`Event Loop Thread`】，当你从事件循环中调用`Core API`时，`VertX`会生成对应的`Handler`，而这个`Handler`会在同一个事件循环中被执行。

也就是说：`VertX`保证了你写的`VertX Instance`中的代码在同一个事件循环中执行。

<font style="color:blue">这种情况下，你可以讲你的所有应用代码按照单线程模式来书写，并且不需要去考虑多线程和水平扩展问题，也不需要考虑同步以及线程安全性问题，这种开发方式和传统意义中的开发方式是相同的。</font>

#### 8.2.`Worker Verticles`

`Worker Verticle`和`Standard Verticle`有点类似，但是其不同在于这种类型的`Verticle`并不是使用一个事件循环【`Event Loop`】，而是直接从`Vert.X`的工作线程池中使用一个线程来实现。这种类型的`Verticle`主要的设计目的是在于调用阻塞式代码，上边已经提到过了，如果需要实现阻塞方式的调用，除了内联方式【`Inline Blocking Code`】，就是直接使用`Worker Verticle`。

下边的代码可以将一个`Verticle`通过编程方式设置成`Worker Verticle`

	DeploymentOptions options = new DeploymentOptions().setWorker(true);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

<font style="color:blue">`Worker Verticle`的实例不可以被超过一个线程的`Vert.X`并发访问，但是它可以被不同的线程执行很多次。</font>

#### 8.3.`Multi-threaded Worker Verticle`

这种方式的`Verticle`是`3.0`出现的新方式，他和普通的`Worker Verticle`差不多，唯一的区别是可以被线程并发访问。

<font style="color:blue">这种类型的`Verticle`属于高级功能，大部分应用都不会使用到，因为这种方式会让开发人员考虑多线程环境中的对象并发访问状态的同步，以及更多标准多线程应用需要考虑的问题。</font>

<hr/>

### 9.编程方式发布`Verticle`

你可以使用`deployVerticle`方法来发布一个写好的`Verticle`，这种情况下仅需要`Verticle`的名字或者直接传入一个`Verticle`实例<font style="color:red">【实例传入的方式仅`Java`语言可支持！】</font>即可。

	Verticle myVerticle = new MyVerticle();
	vertx.deployVerticle(myVerticle);

除了上边的发布方式，还可以直接将一个`Verticle`的名称传入给`VerticleFactory`类，让这个类来实例化一个`Verticle`，不同的`Factory`可以针对不同语言写的`Verticle`实现实例化的操作，也就是说使用`name`的方式可以发布任何语言写的`Verticle`，如：

	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle");

	// Deploy a JavaScript verticle
	vertx.deployVerticle("verticles/myverticle.js");

	// Deploy a Ruby verticle verticle
	vertx.deployVerticle("verticles/my_verticle.rb");

如果使用`name`实现发布，还可以通过不同的命名方式，在不加任何前缀的时候，`VertX`会使用`Java`语言的`FQCN`【`Fully Qualified Class Name`】来实例化这个`Verticle`，而使用前缀的方式如下：

	js:foo.js // Use the JavaScript verticle factory
	groovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory
	service:com.mycompany:myorderservice // Uses the service verticle factory
如果前缀匹配有问题，还会使用后缀匹配的默认规则，如：

	foo.js // Will also use the JavaScript verticle factory
	SomeScript.groovy // Will use the Groovy verticle factory
<hr/>

### 10.`Verticle`的定位
大部分`Verticle`的工厂类都是直接从`CLASSPATH`中读取，并且在`Vert.X`启动的时候注册的，如果有必要可以使用`registerVerticleFactory`和`unregisterVerticleFactory`的方式手动注册以及注销`Verticle`的工厂类。

_Deployment_

	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", res -> {
		if (res.succeeded()) {
			System.out.println("Deployment id is: " + res.result());
		} else {
			System.out.println("Deployment failed!");
		}
	});

_Undeployment_

	vertx.undeploy(deploymentID, res -> {
		if (res.succeeded()) {
			System.out.println("Undeployed ok");
		} else {
			System.out.println("Undeploy failed!");
		}
	});

如果使用`Verticle`的名称来发布`VertX`的实例，可以在发布的时候指定`Verticle`运行的实例数量：

	DeploymentOptions options = new DeploymentOptions().setInstances(16);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

<hr/>

### 11.配置传递

`VertX`使用的配置本身可直接用`JSON`格式的数据进行编程设置：

	JsonObject config = new JsonObject().put("name", "tim").put("directory", "/blah");
	DeploymentOptions options = new DeploymentOptions().setConfig(config);
	vertx.deployVerticle("com.mycompany.MyOrderProcessorVerticle", options);

这个配置一旦初始化好了过后，会存在于上下文环境对象`Context`中，而且可以使用`config()`方法直接获取引用，如：

	System.out.println("Configuration: " + config().getString("name"));
除了上边的配置读写以外，还可以使用下边方式获取环境信息【`Java`信息】：

	System.getProperty("prop");
	System.getenv("HOME");

<hr/>

### 12.`Verticle`的独立组

默认情况下，`Vert.X`拥有一个平坦的`CLASSPATH`【`Flat Classpath`】，当`Vert.X`发布`Verticle`的时候它会使用当前的类加载器，它并不会创建一个新的，这种情况是最简单并且最直接的方式。

除了上边的情况以外，`Vert.X`提供了一个独立分组机制，这种情况使得不同的应用会拥有不同的类加载器【`ClassLoader`】——比如你想要`Deploy`两个不同版本的`Verticle`的同一个`Vert.X`实例，则需要使用各自独立的`CLASSPATH`的分组才可以。

使用编程的方式`setIsolatedClasses`可设置其类路径信息

* 全类名：`com.mycompany.myproject.engine.MyClass`
* 所有包内的类集合：`com.mycompany.myproject.*`

和`JVM`的类加载一样，`Vert.X`可以使用`setExtraClasspath`方法实现扩展类加载器【`Extension ClassLoader`】。

	DeploymentOptions options = new DeploymentOptions().setIsolationGroup("mygroup");
	options.setIsolatedClasses(Arrays.asList("com.mycompany.myverticle.*","com.mycompany.somepkg.SomeClass", "org.somelibrary.*"));
	vertx.deployVerticle("com.mycompany.myverticle.VerticleClass", options);

<hr/>

### 13.简单命令

`Vert.X`可以发布成`HA`【`High Availability`】架构，当发布的一个`Vert.X`出现问题的时候，系统会自动重发布另外的一个`Vert.X`实例来实现`HA`的功能，使用命令如：

	vertx run my-verticle.js -ha
只是有一个限制是必须使用参数：`-cluster`。

新版的`Vert.X`取消了原来的`Mod`结构，可以直接使用`Maven`或`Gradle`方式生成对应的模块，除此之外也可以直接从命令行运行。

* 确认`Vert.X`已经安装好了，并且将`bin`目录添加到系统的`PATH`中了，`vertx`命令可直接从命令行使用；
* 配置了`JDK 8`的系统环境，保证`java`命令可用；

运行实例：

	# Run a JavaScript verticle
	vertx run my_verticle.js

	# Run a Ruby verticle
	vertx run a_n_other_verticle.rb

	# Run a Groovy script verticle, clustered
	vertx run FooVerticle.groovy -cluster

Java版本的可以实现实时编译，直接运行`Java`的源代码：

	vertx run SomeJavaSourceFile.java

关于`Vert.X`的退出：

* `Vert.X`实例运行的线程并不是守护线程【`Daemon Threads`】，所以它会阻止`JVM`本身的退出；
* 如果`Vert.X`嵌入在你的应用中，则你可以调用`close`方法退出`Vert.X`，这种情况更加正规，会将所有对应资源释放包括内部线程池，最后允许`JVM`退出；

<hr/>

### 14.`Context`对象
当`Vert.X`传递一个`event`事件给`handler`或者调用`Verticle`的`start`或`stop`方法时，它执行的时候都会关联一个`Context`上下文环境，通常一个上下文环境是一个事件循环上下文【`Event-Loop Context`】，而且它本身使用了一个特殊的事件循环线程。

获取方式：

	Context context = vertx.getOrCreateContext();
下边代码是测试获取代码：

	Context context = vertx.getOrCreateContext();
	if (context.isEventLoopContext()) {
		System.out.println("Context attached to Event Loop");
	} else if (context.isWorkerContext()) {
		System.out.println("Context attached to Worker Thread");
	} else if (context.isMultiThreadedWorkerContext()) {
		System.out.println("Context attached to Worker Thread - multi threaded worker");
	} else if (! Context.isOnVertxThread()) {
		System.out.println("Context not attached to a thread managed by vert.x");
	}

一旦获取到了一个`Context`过后，就可以异步运行这个`Context`了

	vertx.getOrCreateContext().runOnContext( (v) -> {
		System.out.println("This will be executed asynchronously in the same context");
	});

如果一个`Vert.X`中运行了多个`Handler`，并且它们之间需要共享数据的时候，则可以将共享数据存放在`Context`中实现共享：

	final Context context = vertx.getOrCreateContext();
	context.put("data", "hello");
	context.runOnContext((v) -> {
		String hello = context.get("data");
	});

<hr/>

### 15.执行“周期”和“延迟”行为【`Periodic & Delayed`】
`Vert.X`可支持执行“周期”和“延迟”行为，在`Standard Verticle`中仅仅需要让线程休眠就可以实现延迟行为，这样它就会阻塞`Event Loop`线程：<font style="color:red">【*：这个是破坏了“黄金法则”的】</font>

除开上边的方法以外，也可以设置`Timer`来实现一次性或者周期性行为。

**`One-Shot Timers`**

	long timerID = vertx.setTimer(1000, id -> {
		System.out.println("And one second later this is printed");
	});

	System.out.println("First this is printed");

**`Periodic Timers`**

	long timerID = vertx.setPeriodic(1000, id -> {
		System.out.println("And every second this is printed");
	});

	System.out.println("First this is printed");

<font style="color:blue">取消一个`Timer`时可使用下边代码段，注意上边的调用中`id`就是返回的timer的ID号：</font>

	vertx.cancelTimer(timerID);

<hr/>




### 16.`Event Bus`事件总线

`Event Bus`是`Vert.X`中的神经系统【`Nervous System`】，每一个`Vert.X`实例有一个单独的`Event Bus`的实例，可直接通过方法`eventBus`来获得。它可以让相同或者不同的`Vert.X Instance`中的不同语言写的应用相互之间进行交互，不仅仅如此，它还可以让浏览器中的`JavaScript`和服务端进行直接的数据共享。

`Event Bus`实际上可以在多节点、多浏览器之间实现点对点的通讯，而且它支持下边三种模式：

* `Publish/Subscribe`
* `Point to Point`
* `Request-Response`

而它对应的API相对比较简单。

**相关理论【`Theory`】术语**

* **Addressing**<br/>
地址是`Event Bus`中的一个虚拟概念，所有的`Message`都会发送到地址上，`Vert.X`中使用的地址格式就是字符串，任何字符串都是符合规则的；

* **Handlers**<br/>
`Message`消息会被`Handler`所接受，而所有的`Handler`都必须注册在一个地址上，不同的`Handler`可以注册在不同的地址上，而相同的`Handler`也可以注册在不同的地址上；

* **Publish / Subscribe Messaging**<br/>
`EventBus`事件总线可支持发布消息的功能，这些消息会发布在一个地址上，发布消息会将消息通知发送给所有注册过的`Handler`上，这种模式类似于`Publish/Subscribe`消息模式；

* **Point to Point/Request-Response Messaging**<br/>
`EventBus`还支持`P2P`的点对点消息模式，消息会发送给地址，`Vert.X`则会使用路由功能将请求路由给某一个注册好的`Handler`中，如果这里注册的`handler`有很多，则其中一个会被筛选出来接收这个消息，它使用了并不严格的轮询模式。<br/>
<font style="color:blue">而下边的方式则是`Request-Response`消息模式：</font>
	* 如果一条消息被接受者接收，并且被对应的`Handler`处理，则接受者可以选择回复这条消息，这种情况下会调用`Reply Handler`来完成；
	* 如果这条消息响应给发送者，同样也可以被再次响应，这样的方式可实现双向通讯；
* **Best-effort Delivery**<br/>
`Vert.X`一般情况下会尽可能保证消息不会出现丢失的情况，这种机制称为`Best-Effort`，但是如果`EventBus`中出现了大面积错误信息，则也可能出现消息丢失的情况，如果你的应用是不允许信息丢失的，那么则要在代码中考虑好如何书写以及确保才可以，以及对应的`Recovery`机制；

* **Type of Messages**<br/>
`OOB`的`Vert.X`允许这几种类型在`EventBus`中传播：`Primitive/Simple，String，Buffers`，而在`Vert.X`另外一种很方便的类型就是使用`JSON`，而且它原生支持了`JSON`格式的数据类型，`JSON`则在`Vert.X`中更加通用，而`Vert.X`中的`Handler`也可以调用序列化或者反序列化系统来实现数据到对象的转换过程。

<hr/>

### 17.`Event Bus`的API

1. 获取`Event Bus`，每一个`Vert.X`实例都有一个单独的`Event Bus`的实例

		EventBus eb = vertx.eventBus();
2. 最简单的注册`Handler`的方式是使用`Consumer`

		EventBus eb = vertx.eventBus();
		eb.consumer("news.uk.sport", message -> {
			System.out.println("I have received a message: " + message.body());
		});
	* 当`Handler`接收到消息过后，就会被调用，并且传入消息`message`；
	* 调用`consumer()`方法的返回实例是`MessageConsumer`类型的实例；
	* 返回对象可用于注销【`Unregister`】一个`Handler`，或者使用流数据的方式；

3. 使用`Consumer`而不需要设置`Handler`而返回`MessageConsumer`，随后再来设置

		EventBus eb = vertx.eventBus();

		MessageConsumer<String> consumer = eb.consumer("news.uk.sport");
		consumer.handler(message -> {
			System.out.println("I have received a message: " + message.body());
		});
4. 如果是在一个集群的`Event Bus`中注册一个`Handler`，则需要在集群中的每一个节点都注册这个`handler`，所以需要消耗一定的时间；如果想要人工干预，收到完成的通知，则可以在`MessageConsumer`对象中注册`completion handler`来实现。

		consumer.completionHandler(res -> {
			if (res.succeeded()) {
				System.out.println("The handler registration has reached all nodes");
			} else {
				System.out.println("Registration failed!");
			}
		});
5. 卸载【`Un-registering`】`Handler`，可以通过调用`unregister`来卸载某个`Handler`，如果是在一个`Cluster`中，则：

		consumer.unregister(res -> {
			if (res.succeeded()) {
				System.out.println("The handler un-registration has reached all nodes");
			} else {
				System.out.println("Un-registration failed!");
			}
		});

6. 发布消息【`Publishing Messages`】，下边代码将在地址`news.uk.sport`中发布消息：

		eventBus.publish("news.uk.sport", "Yay! Someone kicked a ball");
7. 发送消息【`Sending Messages`】，向地址中发送消息：

		eventBus.send("news.uk.sport", "Yay! Someone kicked a ball");
8. 发送头部信息，`DeliveryOptions`可在发送消息和发布消息的时候设置相关信息，而且消息可以带消息头：

		DeliveryOptions options = new DeliveryOptions();
		options.addHeader("some-header", "some-value");
		eventBus.send("news.uk.sport", "Yay! Someone kicked a ball", options);
<font style="color:red">从消息处理器【`message handler`】中接收到的消息对象为`Message`，消息的内容部分就可以发布或者发送，并且存储在`body`中，而消息头的信息存储在`headers`中。</font>
9. 消息回复【`Replying to Messages`】<br/>
作为接受者【`Receiver`】：

		MessageConsumer<String> consumer = eventBus.consumer("news.uk.sport");
		consumer.handler(message -> {
			System.out.println("I have received a message: " + message.body());
			message.reply("how interesting!");
		});
作为发送者【`Sender`】：

		eventBus.send("news.uk.sport", "Yay! Someone kicked a ball across a patch of grass", ar -> {
			if (ar.succeeded()) {
    			System.out.println("Received reply: " + ar.result().body());
			}
		});
10. 超时设置，发送消息的时候可以在`Reply Handler`中设置超时选项，在`DeliveryOptions`类中可设置该选项，如果一直没有任何回复或者响应，超过时间就默认为请求失败，默认时间为`30`秒。
11. 发送失败【`Send Failure`】，处理上边提到的发送失败以外，还有下边的原因导致消息发送失败：
	* 针对发送的消息没有可用的消息处理器；
	* 使用显示调用`fail`导致消息发送失败；
12. 消息编码【`Message Codecs`】，在`Event Bus`中可设置消息的消息编码/解码器，同样在`DeliveryOptions`中设置

		eventBus.registerCodec(myCodec);

		DeliveryOptions options = new DeliveryOptions().setCodecName(myCodec.name());

		eventBus.send("orders", new MyPOJO(), options);
如果你总是使用了同一个消息编码解码器来完成交互，那么可直接设置默认的编码/解码方式：

		eventBus.registerDefaultCodec(MyPOJO.class, myCodec);

		eventBus.send("orders", new MyPOJO());

13. 除了编码/解码器的注册以外，还可以通过手动方式卸载【`unregisterCodec`】，编码/解码器有一个好处就是不要求其编码和解码的对象保持一致类型，例：
	* Encoding：MyPOJO Class
	* Decoding：MyOtherPOJO Class

14. 集群的`Event Bus`，如果一个事件总线需要在不同的`Vert.X`的实例中运行，则需要使用分布式集群的`Event Bus`，其编程的方式操作如下：

		VertxOptions options = new VertxOptions();
		Vertx.clusteredVertx(options, res -> {
			if (res.succeeded()) {
				Vertx vertx = res.result();
				EventBus eventBus = vertx.eventBus();
				System.out.println("We now have a clustered event bus: " + eventBus);
			} else {
				System.out.println("Failed: " + res.cause());
			}
		});
<font style="color:red">*：在这种情况下可实现自定义的`ClusterManager`，默认类为`HazelcastClusterManager`</font>，运行集群版的`VertX`的命令如下：

		vertx run my-verticle.js -cluster

<hr/>

### 18. JSON
因为Java语言中没有原生的对`Json`格式支持的类，所以`Vert.X`中提供了两个类主要用于`Json`数据格式的处理。

#### 18.1.JSON对象

1. 创建`JSON`对象

		String jsonString = "{\"foo\":\"bar\"}";
		JsonObject object = new JsonObject(jsonString);
2. 将一个实体对象放到`JSON`对象中

		JsonObject object = new JsonObject();
		object.put("foo", "bar").put("num", 123).put("mybool", true);
3. 从`JSON`对象中获取对应的数据：

		String val = jsonObject.getString("some-key");
		int intVal = jsonObject.getInteger("some-other-key");

#### 18.2.JSON数组

1. 创建`JSON`数组

		String jsonString = "[\"foo\",\"bar\"]";
		JsonArray array = new JsonArray(jsonString);
2. 添加实体到`JSON`数组

		JsonArray array = new JsonArray();
		array.add("foo").add(123).add(false);
3. 从`JSON`数组中获取数据

		String val = array.getString(0);
		Integer intVal = array.getInteger(1);
		Boolean boolVal = array.getBoolean(2);

<hr/>

### 19. Buffer

1. 创建一个Buffer通常可使用`Buffer.buffer`方法，一个缓冲区可以是`String, Byte, Empty`类型的
	* 创建空的缓冲区

			Buffer buff = Buffer.buffer();
	* 字符串类型的缓冲区【`UTF-8`】

			Buffer buff = Buffer.buffer("some string");
	* 使用指定编码格式的字符串缓冲区

			Buffer buff = Buffer.buffer("some string", "UTF-16");
	* 创建字节缓冲区

			byte[] bytes = new byte[] {1, 3, 5};
			Buffer buff = Buffer.buffer(bytes);
	* 创建带容量的缓冲区，注这种缓冲区还是属于空的缓冲区

			Buffer buff = Buffer.buffer(10000);
2. 写入数据到`Buffer`中，缓冲区的写入包含两种方式：`Appending`和`Random Access`，越界的时候和数组不一样并不会抛出`IndexOutOfBoundException`的错
	* Appending to a Buffer

			Buffer buff = Buffer.buffer();

			buff.appendInt(123).appendString("hello\n");

			socket.write(buff);
	* Random access buffer writes

			Buffer buff = Buffer.buffer();

			buff.setInt(1000, 123);
			buff.setString(0, "hello");
3. 从`Buffer`中读取数据

		Buffer buff = Buffer.buffer();
		for (int i = 0; i < buff.length(); i += 4) {
			System.out.println("int value at " + i + " is " + buff.getInt(i));
		}

<font style="color:red">*：其他内容在后边使用的时候来讨论：`Buffer Length, Copy Buffer, Slicing Buffer, Buffer Re-use`</font>








<hr/>



Writing TCP servers and clients

Vert.x allows you to easily write non blocking TCP clients and servers.
Creating a TCP server

The simplest way to create a TCP server, using all default options is as follows:

NetServer server = vertx.createNetServer();

Configuring a TCP server

If you don’t want the default, a server can be configured by passing in a NetServerOptions instance when creating it:

NetServerOptions options = new NetServerOptions().setPort(4321);
NetServer server = vertx.createNetServer(options);

Start the Server Listening

To tell the server to listen for incoming requests you use one of the listen alternatives.

To tell the server to listen at the host and port as specified in the options:

NetServer server = vertx.createNetServer();
server.listen();

Or to specify the host and port in the call to listen, ignoring what is configured in the options:

NetServer server = vertx.createNetServer();
server.listen(1234, "localhost");

The default host is 0.0.0.0 which means 'listen on all available addresses' and the default port is 0, which is a special value that instructs the server to find a random unused local port and use that.

The actual bind is asynchronous so the server might not actually be listening until some time after the call to listen has returned.

If you want to be notified when the server is actually listening you can provide a handler to the listen call. For example:

NetServer server = vertx.createNetServer();
server.listen(1234, "localhost", res -> {
  if (res.succeeded()) {
    System.out.println("Server is now listening!");
  } else {
    System.out.println("Failed to bind!");
  }
});

Listening on a random port

If 0 is used as the listening port, the server will find an unused random port to listen on.

To find out the real port the server is listening on you can call actualPort.

NetServer server = vertx.createNetServer();
server.listen(0, "localhost", res -> {
  if (res.succeeded()) {
    System.out.println("Server is now listening on actual port: " + server.actualPort());
  } else {
    System.out.println("Failed to bind!");
  }
});

Getting notified of incoming connections

To be notified when a connection is made you need to set a connectHandler:

NetServer server = vertx.createNetServer();
server.connectHandler(socket -> {
  // Handle the connection in here
});

When a connection is made the handler will be called with an instance of NetSocket.

This is a socket-like interface to the actual connection, and allows you to read and write data as well as do various other things like close the socket.
Reading data from the socket

To read data from the socket you set the handler on the socket.

This handler will be called with an instance of Buffer every time data is received on the socket.

NetServer server = vertx.createNetServer();
server.connectHandler(socket -> {
  socket.handler(buffer -> {
    System.out.println("I received some bytes: " + buffer.length());
  });
});

Writing data to a socket

You write to a socket using one of write.

Buffer buffer = Buffer.buffer().appendFloat(12.34f).appendInt(123);
socket.write(buffer);

// Write a string in UTF-8 encoding
socket.write("some data");

// Write a string using the specified encoding
socket.write("some data", "UTF-16");

Write operations are asynchronous and may not occur until some time after the call to write has returned.
Closed handler

If you want to be notified when a socket is closed, you can set a closeHandler on it:

socket.closeHandler(v -> {
  System.out.println("The socket has been closed");
});

Handling exceptions

You can set an exceptionHandler to receive any exceptions that happen on the socket.
Event bus write handler

Every socket automatically registers a handler on the event bus, and when any buffers are received in this handler, it writes them to itself.

This enables you to write data to a socket which is potentially in a completely different verticle or even in a different Vert.x instance by sending the buffer to the address of that handler.

The address of the handler is given by writeHandlerID
Local and remote addresses

The local address of a NetSocket can be retrieved using localAddress.

The remote address, (i.e. the address of the other end of the connection) of a NetSocket can be retrieved using remoteAddress.
Sending files or resources from the classpath

Files and classpath resources can be written to the socket directly using sendFile. This can be a very efficient way to send files, as it can be handled by the OS kernel directly where supported by the operating system.

Please see the chapter about serving files from the classpath for restrictions of the classpath resolution or disabling it.

socket.sendFile("myfile.dat");

Streaming sockets

Instances of NetSocket are also ReadStream and WriteStream instances so they can be used to pump data to or from other read and write streams.

See the chapter on streams and pumps for more information.
Upgrading connections to SSL/TLS

A non SSL/TLS connection can be upgraded to SSL/TLS using upgradeToSsl.

The server or client must be configured for SSL/TLS for this to work correctly. Please see the chapter on SSL/TLS for more information.
Closing a TCP Server

Call close to close the server. Closing the server closes any open connections and releases all server resources.

The close is actually asynchronous and might not complete until some time after the call has returned. If you want to be notified when the actual close has completed then you can pass in a handler.

This handler will then be called when the close has fully completed.

server.close(res -> {
  if (res.succeeded()) {
    System.out.println("Server is now closed");
  } else {
    System.out.println("close failed");
  }
});

Automatic clean-up in verticles

If you’re creating TCP servers and clients from inside verticles, those servers and clients will be automatically closed when the verticle is undeployed.
Scaling - sharing TCP servers

The handlers of any TCP server are always executed on the same event loop thread.

This means that if you are running on a server with a lot of cores, and you only have this one instance deployed then you will have at most one core utilised on your server.

In order to utilise more cores of your server you will need to deploy more instances of the server.

You can instantiate more instances programmatically in your code:

for (int i = 0; i < 10; i++) {
  NetServer server = vertx.createNetServer();
  server.connectHandler(socket -> {
    socket.handler(buffer -> {
      // Just echo back the data
      socket.write(buffer);
    });
  });
  server.listen(1234, "localhost");
}

or, if you are using verticles you can simply deploy more instances of your server verticle by using the -instances option on the command line:

vertx run com.mycompany.MyVerticle -instances 10

or when programmatically deploying your verticle

DeploymentOptions options = new DeploymentOptions().setInstances(10);
vertx.deployVerticle("com.mycompany.MyVerticle", options);

Once you do this you will find the echo server works functionally identically to before, but all your cores on your server can be utilised and more work can be handled.

At this point you might be asking yourself 'How can you have more than one server listening on the same host and port? Surely you will get port conflicts as soon as you try and deploy more than one instance?'

Vert.x does a little magic here.*

When you deploy another server on the same host and port as an existing server it doesn’t actually try and create a new server listening on the same host/port.

Instead it internally maintains just a single server, and, as incoming connections arrive it distributes them in a round-robin fashion to any of the connect handlers.

Consequently Vert.x TCP servers can scale over available cores while each instance remains single threaded.
Creating a TCP client

The simplest way to create a TCP client, using all default options is as follows:

NetClient client = vertx.createNetClient();

Configuring a TCP client

If you don’t want the default, a client can be configured by passing in a NetClientOptions instance when creating it:

NetClientOptions options = new NetClientOptions().setConnectTimeout(10000);
NetClient client = vertx.createNetClient(options);

Making connections

To make a connection to a server you use connect, specifying the port and host of the server and a handler that will be called with a result containing the NetSocket when connection is successful or with a failure if connection failed.

NetClientOptions options = new NetClientOptions().setConnectTimeout(10000);
NetClient client = vertx.createNetClient(options);
client.connect(4321, "localhost", res -> {
  if (res.succeeded()) {
    System.out.println("Connected!");
    NetSocket socket = res.result();
  } else {
    System.out.println("Failed to connect: " + res.cause().getMessage());
  }
});

Configuring connection attempts

A client can be configured to automatically retry connecting to the server in the event that it cannot connect. This is configured with setReconnectInterval and setReconnectAttempts.
Note
	Currently Vert.x will not attempt to reconnect if a connection fails, reconnect attempts and interval only apply to creating initial connections.

NetClientOptions options = new NetClientOptions().
    setReconnectAttempts(10).
    setReconnectInterval(500);

NetClient client = vertx.createNetClient(options);

By default, multiple connection attempts are disabled.
Configuring servers and clients to work with SSL/TLS

TCP clients and servers can be configured to use Transport Layer Security - earlier versions of TLS were known as SSL.

The APIs of the servers and clients are identical whether or not SSL/TLS is used, and it’s enabled by configuring the NetClientOptions or NetServerOptions instances used to create the servers or clients.
Enabling SSL/TLS on the server

SSL/TLS is enabled with ssl.

By default it is disabled.
Specifying key/certificate for the server

SSL/TLS servers usually provide certificates to clients in order verify their identity to clients.

Certificates/keys can be configured for servers in several ways:

The first method is by specifying the location of a Java key-store which contains the certificate and private key.

Java key stores can be managed with the keytool utility which ships with the JDK.

The password for the key store should also be provided:

NetServerOptions options = new NetServerOptions().setSsl(true).setKeyStoreOptions(
    new JksOptions().
        setPath("/path/to/your/server-keystore.jks").
        setPassword("password-of-your-keystore")
);
NetServer server = vertx.createNetServer(options);

Alternatively you can read the key store yourself as a buffer and provide that directly:

Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.jks");
JksOptions jksOptions = new JksOptions().
    setValue(myKeyStoreAsABuffer).
    setPassword("password-of-your-keystore");
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setKeyStoreOptions(jksOptions);
NetServer server = vertx.createNetServer(options);

Key/certificate in PKCS#12 format (http://en.wikipedia.org/wiki/PKCS_12), usually with the .pfx or the .p12 extension can also be loaded in a similar fashion than JKS key stores:

NetServerOptions options = new NetServerOptions().setSsl(true).setPfxKeyCertOptions(
    new PfxOptions().
        setPath("/path/to/your/server-keystore.pfx").
        setPassword("password-of-your-keystore")
);
NetServer server = vertx.createNetServer(options);

Buffer configuration is also supported:

Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-keystore.pfx");
PfxOptions pfxOptions = new PfxOptions().
    setValue(myKeyStoreAsABuffer).
    setPassword("password-of-your-keystore");
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setPfxKeyCertOptions(pfxOptions);
NetServer server = vertx.createNetServer(options);

Another way of providing server private key and certificate separately using .pem files.

NetServerOptions options = new NetServerOptions().setSsl(true).setPemKeyCertOptions(
    new PemKeyCertOptions().
        setKeyPath("/path/to/your/server-key.pem").
        setCertPath("/path/to/your/server-cert.pem")
);
NetServer server = vertx.createNetServer(options);

Buffer configuration is also supported:

Buffer myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-key.pem");
Buffer myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-cert.pem");
PemKeyCertOptions pemOptions = new PemKeyCertOptions().
    setKeyValue(myKeyAsABuffer).
    setCertValue(myCertAsABuffer);
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setPemKeyCertOptions(pemOptions);
NetServer server = vertx.createNetServer(options);

Keep in mind that pem configuration, the private key is not crypted.
Specifying trust for the server

SSL/TLS servers can use a certificate authority in order to verify the identity of the clients.

Certificate authorities can be configured for servers in several ways:

Java trust stores can be managed with the keytool utility which ships with the JDK.

The password for the trust store should also be provided:

NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setTrustStoreOptions(
        new JksOptions().
            setPath("/path/to/your/truststore.jks").
            setPassword("password-of-your-truststore")
    );
NetServer server = vertx.createNetServer(options);

Alternatively you can read the trust store yourself as a buffer and provide that directly:

Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks");
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setTrustStoreOptions(
        new JksOptions().
            setValue(myTrustStoreAsABuffer).
            setPassword("password-of-your-truststore")
    );
NetServer server = vertx.createNetServer(options);

Certificate authority in PKCS#12 format (http://en.wikipedia.org/wiki/PKCS_12), usually with the .pfx or the .p12 extension can also be loaded in a similar fashion than JKS trust stores:

NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setPfxTrustOptions(
        new PfxOptions().
            setPath("/path/to/your/truststore.pfx").
            setPassword("password-of-your-truststore")
    );
NetServer server = vertx.createNetServer(options);

Buffer configuration is also supported:

Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx");
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setPfxTrustOptions(
        new PfxOptions().
            setValue(myTrustStoreAsABuffer).
            setPassword("password-of-your-truststore")
    );
NetServer server = vertx.createNetServer(options);

Another way of providing server certificate authority using a list .pem files.

NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setPemTrustOptions(
        new PemTrustOptions().
            addCertPath("/path/to/your/server-ca.pem")
    );
NetServer server = vertx.createNetServer(options);

Buffer configuration is also supported:

Buffer myCaAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/server-ca.pfx");
NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setClientAuth(ClientAuth.REQUIRED).
    setPemTrustOptions(
        new PemTrustOptions().
            addCertValue(myCaAsABuffer)
    );
NetServer server = vertx.createNetServer(options);

Enabling SSL/TLS on the client

Net Clients can also be easily configured to use SSL. They have the exact same API when using SSL as when using standard sockets.

To enable SSL on a NetClient the function setSSL(true) is called.
Client trust configuration

If the trustALl is set to true on the client, then the client will trust all server certificates. The connection will still be encrypted but this mode is vulnerable to 'man in the middle' attacks. I.e. you can’t be sure who you are connecting to. Use this with caution. Default value is false.

NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setTrustAll(true);
NetClient client = vertx.createNetClient(options);

If trustAll is not set then a client trust store must be configured and should contain the certificates of the servers that the client trusts.

Likewise server configuration, the client trust can be configured in several ways:

The first method is by specifying the location of a Java trust-store which contains the certificate authority.

It is just a standard Java key store, the same as the key stores on the server side. The client trust store location is set by using the function path on the jks options. If a server presents a certificate during connection which is not in the client trust store, the connection attempt will not succeed.

NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setTrustStoreOptions(
        new JksOptions().
            setPath("/path/to/your/truststore.jks").
            setPassword("password-of-your-truststore")
    );
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.jks");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setTrustStoreOptions(
        new JksOptions().
            setValue(myTrustStoreAsABuffer).
            setPassword("password-of-your-truststore")
    );
NetClient client = vertx.createNetClient(options);

Certificate authority in PKCS#12 format (http://en.wikipedia.org/wiki/PKCS_12), usually with the .pfx or the .p12 extension can also be loaded in a similar fashion than JKS trust stores:

NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPfxTrustOptions(
        new PfxOptions().
            setPath("/path/to/your/truststore.pfx").
            setPassword("password-of-your-truststore")
    );
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/truststore.pfx");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPfxTrustOptions(
        new PfxOptions().
            setValue(myTrustStoreAsABuffer).
            setPassword("password-of-your-truststore")
    );
NetClient client = vertx.createNetClient(options);

Another way of providing server certificate authority using a list .pem files.

NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPemTrustOptions(
        new PemTrustOptions().
            addCertPath("/path/to/your/ca-cert.pem")
    );
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myTrustStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/ca-cert.pem");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPemTrustOptions(
        new PemTrustOptions().
            addCertValue(myTrustStoreAsABuffer)
    );
NetClient client = vertx.createNetClient(options);

Specifying key/certificate for the client

If the server requires client authentication then the client must present its own certificate to the server when connecting. The client can be configured in several ways:

The first method is by specifying the location of a Java key-store which contains the key and certificate. Again it’s just a regular Java key store. The client keystore location is set by using the function path on the jks options.

NetClientOptions options = new NetClientOptions().setSsl(true).setKeyStoreOptions(
    new JksOptions().
        setPath("/path/to/your/client-keystore.jks").
        setPassword("password-of-your-keystore")
);
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.jks");
JksOptions jksOptions = new JksOptions().
    setValue(myKeyStoreAsABuffer).
    setPassword("password-of-your-keystore");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setKeyStoreOptions(jksOptions);
NetClient client = vertx.createNetClient(options);

Key/certificate in PKCS#12 format (http://en.wikipedia.org/wiki/PKCS_12), usually with the .pfx or the .p12 extension can also be loaded in a similar fashion than JKS key stores:

NetClientOptions options = new NetClientOptions().setSsl(true).setPfxKeyCertOptions(
    new PfxOptions().
        setPath("/path/to/your/client-keystore.pfx").
        setPassword("password-of-your-keystore")
);
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-keystore.pfx");
PfxOptions pfxOptions = new PfxOptions().
    setValue(myKeyStoreAsABuffer).
    setPassword("password-of-your-keystore");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPfxKeyCertOptions(pfxOptions);
NetClient client = vertx.createNetClient(options);

Another way of providing server private key and certificate separately using .pem files.

NetClientOptions options = new NetClientOptions().setSsl(true).setPemKeyCertOptions(
    new PemKeyCertOptions().
        setKeyPath("/path/to/your/client-key.pem").
        setCertPath("/path/to/your/client-cert.pem")
);
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myKeyAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-key.pem");
Buffer myCertAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/client-cert.pem");
PemKeyCertOptions pemOptions = new PemKeyCertOptions().
    setKeyValue(myKeyAsABuffer).
    setCertValue(myCertAsABuffer);
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setPemKeyCertOptions(pemOptions);
NetClient client = vertx.createNetClient(options);

Keep in mind that pem configuration, the private key is not crypted.
Revoking certificate authorities

Trust can be configured to use a certificate revocation list (CRL) for revoked certificates that should no longer be trusted. The crlPath configures the crl list to use:

NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setTrustStoreOptions(trustOptions).
    addCrlPath("/path/to/your/crl.pem");
NetClient client = vertx.createNetClient(options);

Buffer configuration is also supported:

Buffer myCrlAsABuffer = vertx.fileSystem().readFileBlocking("/path/to/your/crl.pem");
NetClientOptions options = new NetClientOptions().
    setSsl(true).
    setTrustStoreOptions(trustOptions).
    addCrlValue(myCrlAsABuffer);
NetClient client = vertx.createNetClient(options);

Configuring the Cipher suite

By default, the TLS configuration will uses the Cipher suite of the JVM running Vert.x. This Cipher suite can be configured with a suite of enabled ciphers:

NetServerOptions options = new NetServerOptions().
    setSsl(true).
    setKeyStoreOptions(keyStoreOptions).
    addEnabledCipherSuite("ECDHE-RSA-AES128-GCM-SHA256").
    addEnabledCipherSuite("ECDHE-ECDSA-AES128-GCM-SHA256").
    addEnabledCipherSuite("ECDHE-RSA-AES256-GCM-SHA384").
    addEnabledCipherSuite("CDHE-ECDSA-AES256-GCM-SHA384");
NetServer server = vertx.createNetServer(options);

Cipher suite can be specified on the NetServerOptions or NetClientOptions configuration.
Writing HTTP servers and clients

Vert.x allows you to easily write non blocking HTTP clients and servers.
Creating an HTTP Server

The simplest way to create an HTTP server, using all default options is as follows:

HttpServer server = vertx.createHttpServer();

Configuring an HTTP server

If you don’t want the default, a server can be configured by passing in a HttpServerOptions instance when creating it:

HttpServerOptions options = new HttpServerOptions().setMaxWebsocketFrameSize(1000000);

HttpServer server = vertx.createHttpServer(options);

Start the Server Listening

To tell the server to listen for incoming requests you use one of the listen alternatives.

To tell the server to listen at the host and port as specified in the options:

HttpServer server = vertx.createHttpServer();
server.listen();

Or to specify the host and port in the call to listen, ignoring what is configured in the options:

HttpServer server = vertx.createHttpServer();
server.listen(8080, "myhost.com");

The default host is 0.0.0.0 which means 'listen on all available addresses' and the default port is 80.

The actual bind is asynchronous so the server might not actually be listening until some time after the call to listen has returned.

If you want to be notified when the server is actually listening you can provide a handler to the listen call. For example:

HttpServer server = vertx.createHttpServer();
server.listen(8080, "myhost.com", res -> {
  if (res.succeeded()) {
    System.out.println("Server is now listening!");
  } else {
    System.out.println("Failed to bind!");
  }
});

Getting notified of incoming requests

To be notified when a request arrives you need to set a requestHandler:

HttpServer server = vertx.createHttpServer();
server.requestHandler(request -> {
  // Handle the request in here
});

Handling requests

When a request arrives, the request handler is called passing in an instance of HttpServerRequest. This object represents the server side HTTP request.

The handler is called when the headers of the request have been fully read.

If the request contains a body, that body will arrive at the server some time after the request handler has been called.

The server request object allows you to retrieve the uri, path, params and headers, amongst other things.

Each server request object is associated with one server response object. You use response to get a reference to the HttpServerResponse object.

Here’s a simple example of a server handling a request and replying with "hello world" to it.

vertx.createHttpServer().requestHandler(request -> {
  request.response().end("Hello world");
}).listen(8080);

Request version

The version of HTTP specified in the request can be retrieved with version
Request method

Use method to retrieve the HTTP method of the request. (i.e. whether it’s GET, POST, PUT, DELETE, HEAD, OPTIONS, etc).
Request URI

Use uri to retrieve the URI of the request.

Note that this is the actual URI as passed in the HTTP request, and it’s almost always a relative URI.

The URI is as defined in Section 5.1.2 of the HTTP specification - Request-URI
Request path

Use path to return the path part of the URI

For example, if the request URI was:

a/b/c/page.html?param1=abc&param2=xyz

Then the path would be

/a/b/c/page.html

Request query

Use query to return the query part of the URI

For example, if the request URI was:

a/b/c/page.html?param1=abc&param2=xyz

Then the query would be

param1=abc&param2=xyz

Request headers

Use headers to return the headers of the HTTP request.

This returns an instance of MultiMap - which is like a normal Map or Hash but allows multiple values for the same key - this is because HTTP allows multiple header values with the same key.

It also has case-insensitive keys, that means you can do the following:

MultiMap headers = request.headers();

// Get the User-Agent:
System.out.println("User agent is " + headers.get("user-agent"));

// You can also do this and get the same result:
System.out.println("User agent is " + headers.get("User-Agent"));

Request parameters

Use params to return the parameters of the HTTP request.

Just like headers this returns an instance of MultiMap as there can be more than one parameter with the same name.

Request parameters are sent on the request URI, after the path. For example if the URI was:

/page.html?param1=abc&param2=xyz

Then the parameters would contain the following:

param1: 'abc'
param2: 'xyz

Note that these request parameters are retrieved from the URL of the request. If you have form attributes that have been sent as part of the submission of an HTML form submitted in the body of a multi-part/form-data request then they will not appear in the params here.
Remote address

The address of the sender of the request can be retrieved with remoteAddress.
Absolute URI

The URI passed in an HTTP request is usually relative. If you wish to retrieve the absolute URI corresponding to the request, you can get it with absoluteURI
End handler

The endHandler of the request is invoked when the entire request, including any body has been fully read.
Reading Data from the Request Body

Often an HTTP request contains a body that we want to read. As previously mentioned the request handler is called when just the headers of the request have arrived so the request object does not have a body at that point.

This is because the body may be very large (e.g. a file upload) and we don’t generally want to buffer the entire body in memory before handing it to you, as that could cause the server to exhaust available memory.

To receive the body, you can use the handler on the request, this will get called every time a chunk of the request body arrives. Here’s an example:

request.handler(buffer -> {
  System.out.println("I have received a chunk of the body of length " + buffer.length());
});

The object passed into the handler is a Buffer, and the handler can be called multiple times as data arrives from the network, depending on the size of the body.

In some cases (e.g. if the body is small) you will want to aggregate the entire body in memory, so you could do the aggregation yourself as follows:

Buffer totalBuffer = Buffer.buffer();

request.handler(buffer -> {
  System.out.println("I have received a chunk of the body of length " + buffer.length());
  totalBuffer.appendBuffer(buffer);
});

request.endHandler(v -> {
  System.out.println("Full body received, length = " + totalBuffer.length());
});

This is such a common case, that Vert.x provides a bodyHandler to do this for you. The body handler is called once when all the body has been received:

request.bodyHandler(totalBuffer -> {
  System.out.println("Full body received, length = " + totalBuffer.length());
});

Pumping requests

The request object is a ReadStream so you can pump the request body to any WriteStream instance.

See the chapter on streams and pumps for a detailed explanation.
Handling HTML forms

HTML forms can be submitted with either a content type of application/x-www-form-urlencoded or multipart/form-data.

For url encoded forms, the form attributes are encoded in the url, just like normal query parameters.

For multi-part forms they are encoded in the request body, and as such are not available until the entire body has been read from the wire.

Multi-part forms can also contain file uploads.

If you want to retrieve the attributes of a multi-part form you should tell Vert.x that you expect to receive such a form before any of the body is read by calling setExpectMultipart with true, and then you should retrieve the actual attributes using formAttributes once the entire body has been read:

server.requestHandler(request -> {
  request.setExpectMultipart(true);
  request.endHandler(v -> {
    // The body has now been fully read, so retrieve the form attributes
    MultiMap formAttributes = request.formAttributes();
  });
});

Handling form file uploads

Vert.x can also handle file uploads which are encoded in a multi-part request body.

To receive file uploads you tell Vert.x to expect a multi-part form and set an uploadHandler on the request.

This handler will be called once for every upload that arrives on the server.

The object passed into the handler is a HttpServerFileUpload instance.

server.requestHandler(request -> {
  request.setExpectMultipart(true);
  request.uploadHandler(upload -> {
    System.out.println("Got a file upload " + upload.name());
  });
});

File uploads can be large we don’t provide the entire upload in a single buffer as that might result in memory exhaustion, instead, the upload data is received in chunks:

request.uploadHandler(upload -> {
  upload.handler(chunk -> {
    System.out.println("Received a chunk of the upload of length " + chunk.length());
  });
});

The upload object is a ReadStream so you can pump the request body to any WriteStream instance. See the chapter on streams and pumps for a detailed explanation.

If you just want to upload the file to disk somewhere you can use streamToFileSystem:

request.uploadHandler(upload -> {
  upload.streamToFileSystem("myuploads_directory/" + upload.filename());
});

Warning
	Make sure you check the filename in a production system to avoid malicious clients uploading files to arbitrary places on your filesystem. See security notes for more information.
Sending back responses

The server response object is an instance of HttpServerResponse and is obtained from the request with response.

You use the response object to write a response back to the HTTP client.
Setting status code and message

The default HTTP status code for a response is 200, representing OK.

Use setStatusCode to set a different code.

You can also specify a custom status message with setStatusMessage.

If you don’t specify a status message, the default one corresponding to the status code will be used.
Writing HTTP responses

To write data to an HTTP response, you use one the write operations.

These can be invoked multiple times before the response is ended. They can be invoked in a few ways:

With a single buffer:

HttpServerResponse response = request.response();
response.write(buffer);

With a string. In this case the string will encoded using UTF-8 and the result written to the wire.

HttpServerResponse response = request.response();
response.write("hello world!");

With a string and an encoding. In this case the string will encoded using the specified encoding and the result written to the wire.

HttpServerResponse response = request.response();
response.write("hello world!", "UTF-16");

Writing to a response is asynchronous and always returns immediately after the write has been queued.

If you are just writing a single string or buffer to the HTTP response you can write it and end the response in a single call to the end

The first call to write results in the response header being being written to the response. Consequently, if you are not using HTTP chunking then you must set the Content-Length header before writing to the response, since it will be too late otherwise. If you are using HTTP chunking you do not have to worry.
Ending HTTP responses

Once you have finished with the HTTP response you should end it.

This can be done in several ways:

With no arguments, the response is simply ended.

HttpServerResponse response = request.response();
response.write("hello world!");
response.end();

It can also be called with a string or buffer in the same way write is called. In this case it’s just the same as calling write with a string or buffer followed by calling end with no arguments. For example:

HttpServerResponse response = request.response();
response.end("hello world!");

Closing the underlying connection

You can close the underlying TCP connection with close.

Non keep-alive connections will be automatically closed by Vert.x when the response is ended.

Keep-alive connections are not automatically closed by Vert.x by default. If you want keep-alive connections to be closed after an idle time, then you configure setIdleTimeout.
Setting response headers

HTTP response headers can be added to the response by adding them directly to the headers:

HttpServerResponse response = request.response();
MultiMap headers = response.headers();
headers.set("content-type", "text/html");
headers.set("other-header", "wibble");

Or you can use putHeader

HttpServerResponse response = request.response();
response.putHeader("content-type", "text/html").putHeader("other-header", "wibble");

Headers must all be added before any parts of the response body are written.
Chunked HTTP responses and trailers

Vert.x supports HTTP Chunked Transfer Encoding.

This allows the HTTP response body to be written in chunks, and is normally used when a large response body is being streamed to a client and the total size is not known in advance.

You put the HTTP response into chunked mode as follows:

HttpServerResponse response = request.response();
response.setChunked(true);

Default is non-chunked. When in chunked mode, each call to one of the write methods will result in a new HTTP chunk being written out.

When in chunked mode you can also write HTTP response trailers to the response. These are actually written in the final chunk of the response.

To add trailers to the response, add them directly to the trailers.

HttpServerResponse response = request.response();
response.setChunked(true);
MultiMap trailers = response.trailers();
trailers.set("X-wibble", "woobble").set("X-quux", "flooble");

Or use putTrailer.

HttpServerResponse response = request.response();
response.setChunked(true);
response.putTrailer("X-wibble", "woobble").putTrailer("X-quux", "flooble");

Serving files directly from disk or the classpath

If you were writing a web server, one way to serve a file from disk would be to open it as an AsyncFile and pump it to the HTTP response.

Or you could load it it one go using readFile and write it straight to the response.

Alternatively, Vert.x provides a method which allows you to serve a file from disk or the filesystem to an HTTP response in one operation. Where supported by the underlying operating system this may result in the OS directly transferring bytes from the file to the socket without being copied through user-space at all.

This is done by using sendFile, and is usually more efficient for large files, but may be slower for small files.

Here’s a very simple web server that serves files from the file system using sendFile:

vertx.createHttpServer().requestHandler(request -> {
  String file = "";
  if (request.path().equals("/")) {
    file = "index.html";
  } else if (!request.path().contains("..")) {
    file = request.path();
  }
  request.response().sendFile("web/" + file);
}).listen(8080);

Sending a file is asynchronous and may not complete until some time after the call has returned. If you want to be notified when the file has been writen you can use sendFile

Please see the chapter about serving files from the classpath for restrictions about the classpath resolution or disabling it.
Note
	If you use sendFile while using HTTPS it will copy through user-space, since if the kernel is copying data directly from disk to socket it doesn’t give us an opportunity to apply any encryption.
Warning
	If you’re going to write web servers directly using Vert.x be careful that users cannot exploit the path to access files outside the directory from which you want to serve them or the classpath It may be safer instead to use Vert.x Web.

When there is a need to serve just a segment of a file, say starting from a given byte, you can achieve this by doing:

vertx.createHttpServer().requestHandler(request -> {
  long offset = 0;
  try {
    offset = Long.parseLong(request.getParam("start"));
  } catch (NumberFormatException e) {
    // error handling...
  }

  long end = Long.MAX_VALUE;
  try {
    end = Long.parseLong(request.getParam("end"));
  } catch (NumberFormatException e) {
    // error handling...
  }

  request.response().sendFile("web/mybigfile.txt", offset, end);
}).listen(8080);

You are not required to supply the length if you want to send a file starting from an offset until the end, in this case you can just do:

vertx.createHttpServer().requestHandler(request -> {
  long offset = 0;
  try {
    offset = Long.parseLong(request.getParam("start"));
  } catch (NumberFormatException e) {
    // error handling...
  }

  request.response().sendFile("web/mybigfile.txt", offset);
}).listen(8080);

Pumping responses

The server response is a WriteStream instance so you can pump to it from any ReadStream, e.g. AsyncFile, NetSocket, WebSocket or HttpServerRequest.

Here’s an example which echoes the request body back in the response for any PUT methods. It uses a pump for the body, so it will work even if the HTTP request body is much larger than can fit in memory at any one time:

vertx.createHttpServer().requestHandler(request -> {
  HttpServerResponse response = request.response();
  if (request.method() == HttpMethod.PUT) {
    response.setChunked(true);
    Pump.pump(request, response).start();
    request.endHandler(v -> response.end());
  } else {
    response.setStatusCode(400).end();
  }
}).listen(8080);

HTTP Compression

Vert.x comes with support for HTTP Compression out of the box.

This means you are able to automatically compress the body of the responses before they are sent back to the client.

If the client does not support HTTP compression the responses are sent back without compressing the body.

This allows to handle Client that support HTTP Compression and those that not support it at the same time.

To enable compression use can configure it with setCompressionSupported.

By default compression is not enabled.

When HTTP compression is enabled the server will check if the client includes an Accept-Encoding header which includes the supported compressions. Commonly used are deflate and gzip. Both are supported by Vert.x.

If such a header is found the server will automatically compress the body of the response with one of the supported compressions and send it back to the client.

Be aware that compression may be able to reduce network traffic but is more CPU-intensive.
Creating an HTTP client

You create an HttpClient instance with default options as follows:

HttpClient client = vertx.createHttpClient();

If you want to configure options for the client, you create it as follows:

HttpClientOptions options = new HttpClientOptions().setKeepAlive(false);
HttpClient client = vertx.createHttpClient(options);

Making requests

The http client is very flexible and there are various ways you can make requests with it.

Often you want to make many requests to the same host/port with an http client. To avoid you repeating the host/port every time you make a request you can configure the client with a default host/port:

HttpClientOptions options = new HttpClientOptions().setDefaultHost("wibble.com");
// Can also set default port if you want...
HttpClient client = vertx.createHttpClient(options);
client.getNow("/some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

Alternatively if you find yourself making lots of requests to different host/ports with the same client you can simply specify the host/port when doing the request.

HttpClient client = vertx.createHttpClient();

// Specify both port and host name
client.getNow(8080, "myserver.mycompany.com", "/some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

// This time use the default port 80 but specify the host name
client.getNow("foo.othercompany.com", "/other-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

Both methods of specifying host/port are supported for all the different ways of making requests with the client.
Simple requests with no request body

Often, you’ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS and HEAD requests.

The simplest way to do this with the Vert.x http client is using the methods prefixed with Now. For example getNow.

These methods create the http request and send it in a single method call and allow you to provide a handler that will be called with the http response when it comes back.

HttpClient client = vertx.createHttpClient();

// Send a GET request
client.getNow("/some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

// Send a GET request
client.headNow("/other-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

Writing general requests

At other times you don’t know the request method you want to send until run-time. For that use case we provide general purpose request methods such as request which allow you to specify the HTTP method at run-time:

HttpClient client = vertx.createHttpClient();

client.request(HttpMethod.GET, "some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
}).end();

client.request(HttpMethod.POST, "foo-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
}).end("some-data");

Writing request bodies

Sometimes you’ll want to write requests which have a body, or perhaps you want to write headers to a request before sending it.

To do this you can call one of the specific request methods such as post or one of the general purpose request methods such as request.

These methods don’t send the request immediately, but instead return an instance of HttpClientRequest which can be used to write to the request body or write headers.

Here are some examples of writing a POST request with a body: m

HttpClient client = vertx.createHttpClient();

HttpClientRequest request = client.post("some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

// Now do stuff with the request
request.putHeader("content-length", "1000");
request.putHeader("content-type", "text/plain");
request.write(body);

// Make sure the request is ended when you're done with it
request.end();

// Or fluently:

client.post("some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
}).putHeader("content-length", "1000").putHeader("content-type", "text/plain").write(body).end();

// Or event more simply:

client.post("some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
}).putHeader("content-type", "text/plain").end(body);

Methods exist to write strings in UTF-8 encoding and in any specific encoding and to write buffers:

request.write("some data");

// Write string encoded in specific encoding
request.write("some other data", "UTF-16");

// Write a buffer
Buffer buffer = Buffer.buffer();
buffer.appendInt(123).appendLong(245l);
request.write(buffer);

If you are just writing a single string or buffer to the HTTP request you can write it and end the request in a single call to the end function.

request.end("some simple data");

// Write buffer and end the request (send it) in a single call
Buffer buffer = Buffer.buffer().appendDouble(12.34d).appendLong(432l);
request.end(buffer);

When you’re writing to a request, the first call to write will result in the request headers being written out to the wire.

The actual write is asynchronous and might not occur until some time after the call has returned.

Non-chunked HTTP requests with a request body require a Content-Length header to be provided.

Consequently, if you are not using chunked HTTP then you must set the Content-Length header before writing to the request, as it will be too late otherwise.

If you are calling one of the end methods that take a string or buffer then Vert.x will automatically calculate and set the Content-Length header before writing the request body.

If you are using HTTP chunking a a Content-Length header is not required, so you do not have to calculate the size up-front.
Writing request headers

You can write headers to a request using the headers multi-map as follows:

MultiMap headers = request.headers();
headers.set("content-type", "application/json").set("other-header", "foo");

The headers are an instance of MultiMap which provides operations for adding, setting and removing entries. Http headers allow more than one value for a specific key.

You can also write headers using putHeader

request.putHeader("content-type", "application/json").putHeader("other-header", "foo");

If you wish to write headers to the request you must do so before any part of the request body is written.
Ending HTTP requests

Once you have finished with the HTTP request you must end it with one of the end operations.

Ending a request causes any headers to be written, if they have not already been written and the request to be marked as complete.

Requests can be ended in several ways. With no arguments the request is simply ended:

request.end();

Or a string or buffer can be provided in the call to end. This is like calling write with the string or buffer before calling end with no arguments

request.end("some-data");

// End it with a buffer
Buffer buffer = Buffer.buffer().appendFloat(12.3f).appendInt(321);
request.end(buffer);

Chunked HTTP requests

Vert.x supports HTTP Chunked Transfer Encoding for requests.

This allows the HTTP request body to be written in chunks, and is normally used when a large request body is being streamed to the server, whose size is not known in advance.

You put the HTTP request into chunked mode using setChunked.

In chunked mode each call to write will cause a new chunk to be written to the wire. In chunked mode there is no need to set the Content-Length of the request up-front.

request.setChunked(true);

// Write some chunks
for (int i = 0; i < 10; i++) {
  request.write("this-is-chunk-" + i);
}

request.end();

Request timeouts

You can set a timeout for a specific http request using setTimeout.

If the request does not return any data within the timeout period an exception will be passed to the exception handler (if provided) and the request will be closed.
Handling exceptions

You can handle exceptions corresponding to a request by setting an exception handler on the HttpClientRequest instance:

HttpClientRequest request = client.post("some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});
request.exceptionHandler(e -> {
  System.out.println("Received exception: " + e.getMessage());
  e.printStackTrace();
});

This does not handle non 2xx response that need to be handled in the HttpClientResponse code:

HttpClientRequest request = client.post("some-uri", response -> {
  if (response.statusCode() == 200) {
    System.out.println("Everything fine");
    return;
  }
  if (response.statusCode() == 500) {
    System.out.println("Unexpected behavior on the server side");
    return;
  }
});
request.end();

Important
	XXXNow methods cannot receive an exception handler.
Specifying a handler on the client request

Instead of providing a response handler in the call to create the client request object, alternatively, you can not provide a handler when the request is created and set it later on the request object itself, using handler, for example:

HttpClientRequest request = client.post("some-uri");
request.handler(response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

Using the request as a stream

The HttpClientRequest instance is also a WriteStream which means you can pump to it from any ReadStream instance.

For, example, you could pump a file on disk to a http request body as follows:

request.setChunked(true);
Pump pump = Pump.pump(file, request);
file.endHandler(v -> request.end());
pump.start();

Handling http responses

You receive an instance of HttpClientResponse into the handler that you specify in of the request methods or by setting a handler directly on the HttpClientRequest object.

You can query the status code and the status message of the response with statusCode and statusMessage.

client.getNow("some-uri", response -> {
  // the status code - e.g. 200 or 404
  System.out.println("Status code is " + response.statusCode());

  // the status message e.g. "OK" or "Not Found".
  System.out.println("Status message is " + response.statusMessage());
});

Using the response as a stream

The HttpClientResponse instance is also a ReadStream which means you can pump it to any WriteStream instance.
Response headers and trailers

Http responses can contain headers. Use headers to get the headers.

The object returned is a MultiMap as HTTP headers can contain multiple values for single keys.

String contentType = response.headers().get("content-type");
String contentLength = response.headers().get("content-lengh");

Chunked HTTP responses can also contain trailers - these are sent in the last chunk of the response body.

You use trailers to get the trailers. Trailers are also a MultiMap.
Reading the request body

The response handler is called when the headers of the response have been read from the wire.

If the response has a body this might arrive in several pieces some time after the headers have been read. We don’t wait for all the body to arrive before calling the response handler as the response could be very large and we might be waiting a long time, or run out of memory for large responses.

As parts of the response body arrive, the handler is called with a Buffer representing the piece of the body:

client.getNow("some-uri", response -> {

  response.handler(buffer -> {
    System.out.println("Received a part of the response body: " + buffer);
  });
});

If you know the response body is not very large and want to aggregate it all in memory before handling it, you can either aggregate it yourself:

client.getNow("some-uri", response -> {

  // Create an empty buffer
  Buffer totalBuffer = Buffer.buffer();

  response.handler(buffer -> {
    System.out.println("Received a part of the response body: " + buffer.length());

    totalBuffer.appendBuffer(buffer);
  });

  response.endHandler(v -> {
    // Now all the body has been read
    System.out.println("Total response body length is " + totalBuffer.length());
  });
});

Or you can use the convenience bodyHandler which is called with the entire body when the response has been fully read:

client.getNow("some-uri", response -> {

  response.bodyHandler(totalBuffer -> {
    // Now all the body has been read
    System.out.println("Total response body length is " + totalBuffer.length());
  });
});

Response end handler

The response endHandler is called when the entire response body has been read or immediately after the headers have been read and the response handler has been called if there is no body.
Reading cookies from the response

You can retrieve the list of cookies from a response using cookies.

Alternatively you can just parse the Set-Cookie headers yourself in the response.
100-Continue handling

According to the HTTP 1.1 specification a client can set a header Expect: 100-Continue and send the request header before sending the rest of the request body.

The server can then respond with an interim response status Status: 100 (Continue) to signify to the client that it is ok to send the rest of the body.

The idea here is it allows the server to authorise and accept/reject the request before large amounts of data are sent. Sending large amounts of data if the request might not be accepted is a waste of bandwidth and ties up the server in reading data that it will just discard.

Vert.x allows you to set a continueHandler on the client request object

This will be called if the server sends back a Status: 100 (Continue) response to signify that it is ok to send the rest of the request.

This is used in conjunction with `sendHead`to send the head of the request.

Here’s an example:

HttpClientRequest request = client.put("some-uri", response -> {
  System.out.println("Received response with status code " + response.statusCode());
});

request.putHeader("Expect", "100-Continue");

request.continueHandler(v -> {
  // OK to send rest of body
  request.write("Some data");
  request.write("Some more data");
  request.end();
});

On the server side a Vert.x http server can be configured to automatically send back 100 Continue interim responses when it receives an Expect: 100-Continue header.

This is done by setting the option setHandle100ContinueAutomatically.

If you’d prefer to decide whether to send back continue responses manually, then this property should be set to false (the default), then you can inspect the headers and call writeContinue to have the client continue sending the body:

httpServer.requestHandler(request -> {
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    // Send a 100 continue response
    request.response().writeContinue();

    // The client should send the body when it receives the 100 response
    request.bodyHandler(body -> {
      // Do something with body
    });

    request.endHandler(v -> {
      request.response().end();
    });
  }
});

You can also reject the request by sending back a failure status code directly: in this case the body should either be ignored or the connection should be closed (100-Continue is a performance hint and cannot be a logical protocol constraint):

httpServer.requestHandler(request -> {
  if (request.getHeader("Expect").equalsIgnoreCase("100-Continue")) {

    //
    boolean rejectAndClose = true;
    if (rejectAndClose) {

      // Reject with a failure code and close the connection
      // this is probably best with persistent connection
      request.response()
          .setStatusCode(405)
          .putHeader("Connection", "close")
          .end();
    } else {

      // Reject with a failure code and ignore the body
      // this may be appropriate if the body is small
      request.response()
          .setStatusCode(405)
          .end();
    }
  }
});

Enabling compression on the client

The http client comes with support for HTTP Compression out of the box.

This means the client can let the remote http server know that it supports compression, and will be able to handle compressed response bodies.

An http server is free to either compress with one of the supported compression algorithms or to send the body back without compressing it at all. So this is only a hint for the Http server which it may ignore at will.

To tell the http server which compression is supported by the client it will include an Accept-Encoding header with the supported compression algorithm as value. Multiple compression algorithms are supported. In case of Vert.x this will result in the following header added:

Accept-Encoding: gzip, deflate

The server will choose then from one of these. You can detect if a server ompressed the body by checking for the Content-Encoding header in the response sent back from it.

If the body of the response was compressed via gzip it will include for example the following header:

Content-Encoding: gzip

To enable compression set setTryUseCompression on the options used when creating the client.

By default compression is disabled.
Pooling and keep alive

Http keep alive allows http connections to be used for more than one request. This can be a more efficient use of connections when you’re making multiple requests to the same server.

The http client supports pooling of connections, allowing you to reuse connections between requests.

For pooling to work, keep alive must be true using setKeepAlive on the options used when configuring the client. The default value is true.

When keep alive is enabled. Vert.x will add a Connection: Keep-Alive header to each HTTP/1.0 request sent. When keep alive is disabled. Vert.x will add a Connection: Close header to each HTTP/1.1 request sent to signal that the connection will be closed after completion of the response.

The maximum number of connections to pool for each server is configured using setMaxPoolSize

When making a request with pooling enabled, Vert.x will create a new connection if there are less than the maximum number of connections already created for that server, otherwise it will add the request to a queue.

Keep alive connections will not be closed by the client automatically. To close them you can close the client instance.

Alternatively you can set idle timeout using setIdleTimeout - any connections not used within this timeout will be closed. Please note the idle timeout value is in seconds not milliseconds.
Pipe-lining

The client also supports pipe-lining of requests on a connection.

Pipe-lining means another request is sent on the same connection before the response from the preceding one has returned. Pipe-lining is not appropriate for all requests.

To enable pipe-lining, it must be enabled using setPipelining. By default pipe-lining is disabled.

When pipe-lining is enabled requests will be written to connections without waiting for previous responses to return.
HttpClient usage

The HttpClient can be used in a Verticle or embedded.

When used in a Verticle, the Verticle should use its own client instance.

More generally a client should not be shared between different Vert.x contexts as it can lead to unexpected behavior.

For example a keep-alive connection will call the client handlers on the context of the request that opened the connection, subsequent requests will use the same context.

When this happen Vert.x detects it and log a warn:

Reusing a connection with a different context: an HttpClient is probably shared between different Verticles

The HttpClient can be embedded in a non Vert.x thread like a unit test or a plain java main: the client handlers will be called by different Vert.x threads and contexts, such contexts are created as needed. For production this usage is not recommended.
Server sharing

When several HTTP servers listen on the same port, vert.x orchestrates the request handling using a round-robin strategy.

Let’s take a verticle creating a HTTP server such as:
io.vertx.examples.http.sharing.HttpServerVerticle

vertx.createHttpServer().requestHandler(request -> {
  request.response().end("Hello from server " + this);
}).listen(8080);

This service is listening on the port 8080. So, when this verticle is instantiated multiple times as with: vertx run io.vertx.examples.http.sharing.HttpServerVerticle -instances 2, what’s happening ? If both verticles would bind to the same port, you would receive a socket exception. Fortunately, vert.x is handling this case for you. When you deploy another server on the same host and port as an existing server it doesn’t actually try and create a new server listening on the same host/port. It binds only once to the socket. When receiving a request it calls the server handlers following a round robin strategy.

Let’s now imagine a client such as:

vertx.setPeriodic(100, (l) -> {
  vertx.createHttpClient().getNow(8080, "localhost", "/", resp -> {
    resp.bodyHandler(body -> {
      System.out.println(body.toString("ISO-8859-1"));
    });
  });
});

Vert.x delegates the requests to one of the server sequentially:

Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
Hello from i.v.e.h.s.HttpServerVerticle@1
Hello from i.v.e.h.s.HttpServerVerticle@2
...

Consequently the servers can scale over available cores while each Vert.x verticle instance remains strictly single threaded, and you don’t have to do any special tricks like writing load-balancers in order to scale your server on your multi-core machine.
Using HTTPS with Vert.x

Vert.x http servers and clients can be configured to use HTTPS in exactly the same way as net servers.

Please see configuring net servers to use SSL for more information.
WebSockets

WebSockets are a web technology that allows a full duplex socket-like connection between HTTP servers and HTTP clients (typically browsers).

Vert.x supports WebSockets on both the client and server-side.
WebSockets on the server

There are two ways of handling WebSockets on the server side.
WebSocket handler

The first way involves providing a websocketHandler on the server instance.

When a WebSocket connection is made to the server, the handler will be called, passing in an instance of ServerWebSocket.

server.websocketHandler(websocket -> {
  System.out.println("Connected!");
});

You can choose to reject the WebSocket by calling reject.

server.websocketHandler(websocket -> {
  if (websocket.path().equals("/myapi")) {
    websocket.reject();
  } else {
    // Do something
  }
});

Upgrading to WebSocket

The second way of handling WebSockets is to handle the HTTP Upgrade request that was sent from the client, and call upgrade on the server request.

server.requestHandler(request -> {
  if (request.path().equals("/myapi")) {

    ServerWebSocket websocket = request.upgrade();
    // Do something

  } else {
    // Reject
    request.response().setStatusCode(400).end();
  }
});

The server WebSocket

The ServerWebSocket instance enables you to retrieve the headers, path, query and URI of the HTTP request of the WebSocket handshake.
WebSockets on the client

The Vert.x HttpClient supports WebSockets.

You can connect a WebSocket to a server using one of the websocket operations and providing a handler.

The handler will be called with an instance of WebSocket when the connection has been made:

client.websocket("/some-uri", websocket -> {
  System.out.println("Connected!");
});

Writing messages to WebSockets

If you wish to write a single binary WebSocket message to the WebSocket you can do this with writeBinaryMessage:

Buffer buffer = Buffer.buffer().appendInt(123).appendFloat(1.23f);

websocket.writeBinaryMessage(buffer);

If the WebSocket message is larger than the maximum websocket frame size as configured with setMaxWebsocketFrameSize then Vert.x will split it into multiple WebSocket frames before sending it on the wire.
Writing frames to WebSockets

A WebSocket message can be composed of multiple frames. In this case the first frame is either a binary or text frame followed by zero or more continuation frames.

The last frame in the message is marked as final.

To send a message consisting of multiple frames you create frames using WebSocketFrame.binaryFrame , WebSocketFrame.textFrame or WebSocketFrame.continuationFrame and write them to the WebSocket using writeFrame.

Here’s an example for binary frames:

WebSocketFrame frame1 = WebSocketFrame.binaryFrame(buffer1, false);
websocket.writeFrame(frame1);

WebSocketFrame frame2 = WebSocketFrame.continuationFrame(buffer2, false);
websocket.writeFrame(frame2);

// Write the final frame
WebSocketFrame frame3 = WebSocketFrame.continuationFrame(buffer2, true);
websocket.writeFrame(frame3);

In many cases you just want to send a websocket message that consists of a single final frame, so we provide a couple of shortcut methods to do that with writeFinalBinaryFrame and writeFinalTextFrame.

Here’s an example:

websocket.writeFinalTextFrame("Geronimo!");

// Send a websocket messages consisting of a single final binary frame:

Buffer buff = Buffer.buffer().appendInt(12).appendString("foo");

websocket.writeFinalBinaryFrame(buff);

Reading frames from WebSockets

To read frames from a WebSocket you use the frameHandler.

The frame handler will be called with instances of WebSocketFrame when a frame arrives, for example:

websocket.frameHandler(frame -> {
  System.out.println("Received a frame of size!");
});

Closing WebSockets

Use close to close the WebSocket connection when you have finished with it.
Streaming WebSockets

The WebSocket instance is also a ReadStream and a WriteStream so it can be used with pumps.

When using a WebSocket as a write stream or a read stream it can only be used with WebSockets connections that are used with binary frames that are no split over multiple frames.
Automatic clean-up in verticles

If you’re creating http servers and clients from inside verticles, those servers and clients will be automatically closed when the verticle is undeployed.














<hr/>

### 20.数据共享

数据共享的三种方式：

* 在一个应用的不同组件之间共享数据；
* 在同一个`Vert.X`实例的不同应用之间共享数据；
* 在不同的`Vert.X`实例之间跨集群共享数据；

#### 20.1.本地共享映射

`Local Shared Maps`用于在同一个`Vert.X`中的不同`Event Loop`之间共享数据，例如不同的`Verticle`之间共享数据：这种方式共享的数据有一个基本要求就是这些类型必须是不可变类型，并且可以拷贝到`Buffer`中才可以。

		SharedData sd = vertx.sharedData();
		LocalMap<String, String> map1 = sd.getLocalMap("mymap1");
		map1.put("foo", "bar"); // Strings are immutable so no need to copy
		LocalMap<String, Buffer> map2 = sd.getLocalMap("mymap2");
		map2.put("eek", Buffer.buffer().appendInt(123)); // This buffer will be copied before adding to map
		// Then... in another part of your application:
		map1 = sd.getLocalMap("mymap1");
		String val = map1.get("foo");
		map2 = sd.getLocalMap("mymap2");
		Buffer buff = map2.get("eek");

#### 20.2.广泛集群异步映射

`Cluster-wide asynchronous maps`可以在集群中任何一个节点中共享数据，或者从任意节点中读取想让数据，可以调用`getClusterWideMap`方法返回`AsyncMap`来获取对应的实例

		SharedData sd = vertx.sharedData();
		sd.<String, String>getClusterWideMap("mymap", res -> {
			if (res.succeeded()) {
				AsyncMap<String, String> map = res.result();
			} else {
				// Something went wrong!
			}
		});

**将数据填充到`Map`**

		map.put("foo", "bar", resPut -> {
			if (resPut.succeeded()) {
				// Successfully put the value
			} else {
				// Something went wrong!
			}
		});
**从`Map`中读取数据**

		map.get("foo", resGet -> {
			if (resGet.succeeded()) {
				// Successfully got the value
				Object val = resGet.result();
			} else {
				// Something went wrong!
			}
		});

#### 20.3.集群广泛锁

`Cluster-wide locks`集群广泛锁允许跨集群设置排它锁，如果需要抢占资源的程序调用则可以使用这种类型的锁对资源实现锁定调用——注意这种调用方式依然是非阻塞方式的调用，只是带上了“锁”功能，一旦完成了调用过后需要使用`release`方式将锁定资源释放掉以防止资源挂起导致的死锁

		sd.getLock("mylock", res -> {
			if (res.succeeded()) {
				// Got the lock!
				Lock lock = res.result();
				// 5 seconds later we release the lock so someone else can get it
				vertx.setTimer(5000, tid -> lock.release());
			} else {
				// Something went wrong
			}
		});
上边是使用的锁的调用代码，为了防止死锁还可以对锁资源进行超时设置

		sd.getLockWithTimeout("mylock", 10000, res -> {
			if (res.succeeded()) {
				// Got the lock!
				Lock lock = res.result();
			} else {
				// Failed to get lock
			}
		});

#### 20.4.集群广泛计时器

`Cluster-wide counters`用来维护集群应用中不同节点的原子计数器【`Atomic Counter`】

		sd.getCounter("mycounter", res -> {
			if (res.succeeded()) {
				Counter counter = res.result();
			} else {
				// Something went wrong!
			}
		});

<hr/>

### 21.访问文件系统

`Vert.X`中的`FileSystem`对象提供了很多访问文件系统的操作，在`Vert.X`中仅仅存在一个`FileSystem`的实例，可以通过`fileSystem`方法获取到相关引用。`FileSystem`在`Vert.X`中也包含两种版本：`Non-Blocking`和`Blocking`方式，`Non-Blocking`方式的代码如下：

	FileSystem fs = vertx.fileSystem();

	// Copy file from foo.txt to bar.txt
	fs.copy("foo.txt", "bar.txt", res -> {
    	if (res.succeeded()) {
        	// Copied ok!
	    } else {
			// Something went wrong
    	}
	});

而针对`Blocking`的版本所有的操作名称都为`xxxBlocking`，例如`copy`对应的阻塞版本：

	FileSystem fs = vertx.fileSystem();

	// Copy file from foo.txt to bar.txt synchronously
	fs.copyBlocking("foo.txt", "bar.txt");

所有的文件操作如下：

		Vertx vertx = Vertx.vertx();
		// Read a file
		vertx.fileSystem().readFile("target/classes/readme.txt", result -> {
			if (result.succeeded()) {
				System.out.println(result.result());
			} else {
				System.err.println("Oh oh ..." + result.cause());
			}
		});
		// Copy a file
		vertx.fileSystem().copy("target/classes/readme.txt", "target/classes/readme2.txt", result -> {
			if (result.succeeded()) {
				System.out.println("File copied");
			} else {
				System.err.println("Oh oh ..." + result.cause());
			}
		});
		// Write a file
		vertx.fileSystem().writeFile("target/classes/hello.txt", Buffer.buffer("Hello"), result -> {
			if (result.succeeded()) {
				System.out.println("File written");
			} else {
				System.err.println("Oh oh ..." + result.cause());
			}
		});
		// Check existence and delete
		vertx.fileSystem().exists("target/classes/junk.txt", result -> {
			if (result.succeeded() && result.result()) {
				vertx.fileSystem().delete("target/classes/junk.txt", r -> {
					System.out.println("File deleted");
				});
			} else {
				System.err.println("Oh oh ... - cannot delete the file: " + result.cause());
			}
		});

#### 21.1.异步文件【`Asynchronous files`】
`Vert.X`提供了异步文件抽象类用来管理文件系统中的文件，使用`AsyncFile`对象访问文件系统

	OpenOptions options = new OpenOptions();
	fileSystem.open("myfile.txt", options, res -> {
    	if (res.succeeded()) {
    	    AsyncFile file = res.result();
    	} else {
    	    // Something went wrong!
    	}
	});
`AsyncFile`实现了`ReadStream`和`WriteStream`接口，所以可以讲文件转换成流数据进行读写操作以方便非阻塞模式下的数据`I/O`操作。

#### 21.2.随机写【`Random Access Write`】

`AsyncFile`中的`write`方法，参数如下：

* `buffer`：需要写的缓冲区；
* `position`：随机写文件的位置
* `handler`：结果处理器

例子如下：

	Vertx vertx = Vertx.vertx();
	vertx.fileSystem().open("target/classes/hello.txt", new OpenOptions(), result -> {
	    if (result.succeeded()) {
	        AsyncFile file = result.result();
	        Buffer buff = Buffer.buffer("foo");
	        for (int i = 0; i < 5; i++) {
	            file.write(buff, buff.length() * i, ar -> {
	                if (ar.succeeded()) {
	                    System.out.println("Written ok!");
	                    // etc
	                } else {
	                    System.err.println("Failed to write: " + ar.cause());
	                }
	            });
	        }
	    } else {
	        System.err.println("Cannot open file " + result.cause());
	    }
	});

#### 21.3.随机读【`Random Access Read`】

`AsyncFile`的`read`读方法，参数如下：

* `buffer`：读取的缓冲区
* `offset`：读取数据的偏移量
* `position`：读取数据的起始位置
* `length`：读取数据的字节长度
* `handler`：结果处理器

例子如下

	Vertx vertx = Vertx.vertx();
	vertx.fileSystem().open("target/classes/les_miserables.txt", new OpenOptions(), result -> {
	    if (result.succeeded()) {
	        AsyncFile file = result.result();
	        Buffer buff = Buffer.buffer(1000);
	        for (int i = 0; i < 10; i++) {
	            file.read(buff, i * 100, i * 100, 100, ar -> {
	                if (ar.succeeded()) {
	                    System.out.println("Read ok!");
	                } else {
	                    System.err.println("Failed to write: " + ar.cause());
	                }
	            });
	        }
	    } else {
	        System.err.println("Cannot open file " + result.cause());
	    }
	});

#### 21.4.其他

1. 打开文件选项，当打开一个`AsyncFile`文件对象时，可传入一个`OpenOptions`实例，这个实例可限定文件访问的行为，也可以设置对应的权限信息：`setRead, setWrite, setPerms`，针对已经存在的文件也可以设置`setCreateNew`或`setTruncateExisting`，同样可以在`JVM`退出时候调用`setDeleteOnClose`的时候删除已经存在的文件；
2. 将数据`Flush`到后台存储设备中，同步异步的设置方式：`setDSync`，如果要将数据从缓存中直接`Flush`则可调用`flush`方法；
3. `AsyncFile`中`ReadStream`和`WriteStream`的使用

		Vertx vertx = Vertx.vertx();
		final AsyncFile output = vertx.fileSystem().openBlocking("target/classes/plagiary.txt", new OpenOptions());
		vertx.fileSystem().open("target/classes/les_miserables.txt", new OpenOptions(), result -> {
	   		if (result.succeeded()) {
	        	AsyncFile file = result.result();
	        	Pump.pump(file, output).start();
	        	file.endHandler((r) -> {
	            	System.out.println("Copy done");
	        	});
	    	} else {
	        	System.err.println("Cannot open file " + result.cause());
	    	}
		});
4. 关闭`AsyncFile`：通过调用`close`方法用于关闭文件对象。








Datagram sockets (UDP)

Using User Datagram Protocol (UDP) with Vert.x is a piece of cake.

UDP is a connection-less transport which basically means you have no persistent connection to a remote peer.

Instead you can send and receive packages and the remote address is contained in each of them.

Beside this UDP is not as safe as TCP to use, which means there are no guarantees that a send Datagram packet will receive it’s endpoint at all.

The only guarantee is that it will either receive complete or not at all.

Also you usually can’t send data which is bigger then the MTU size of your network interface, this is because each packet will be send as one packet.

But be aware even if the packet size is smaller then the MTU it may still fail.

At which size it will fail depends on the Operating System etc. So rule of thumb is to try to send small packets.

Because of the nature of UDP it is best fit for Applications where you are allowed to drop packets (like for example a monitoring application).

The benefits are that it has a lot less overhead compared to TCP, which can be handled by the NetServer and NetClient (see above).
Creating a DatagramSocket

To use UDP you first need t create a DatagramSocket. It does not matter here if you only want to send data or send and receive.

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());

The returned DatagramSocket will not be bound to a specific port. This is not a problem if you only want to send data (like a client), but more on this in the next section.
Sending Datagram packets

As mentioned before, User Datagram Protocol (UDP) sends data in packets to remote peers but is not connected to them in a persistent fashion.

This means each packet can be sent to a different remote peer.

Sending packets is as easy as shown here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
Buffer buffer = Buffer.buffer("content");
// Send a Buffer
socket.send(buffer, 1234, "10.0.0.1", asyncResult -> {
  System.out.println("Send succeeded? " + asyncResult.succeeded());
});
// Send a String
socket.send("A string used as content", 1234, "10.0.0.1", asyncResult -> {
  System.out.println("Send succeeded? " + asyncResult.succeeded());
});

Receiving Datagram packets

If you want to receive packets you need to bind the DatagramSocket by calling listen(…​)} on it.

This way you will be able to receive DatagramPacket`s that were sent to the address and port on which the `DatagramSocket listens.

Beside this you also want to set a Handler which will be called for each received DatagramPacket.

The DatagramPacket has the following methods:

    sender: The InetSocketAddress which represent the sender of the packet

    data: The Buffer which holds the data which was received.

So to listen on a specific address and port you would do something like shown here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
socket.listen(1234, "0.0.0.0", asyncResult -> {
  if (asyncResult.succeeded()) {
    socket.handler(packet -> {
      // Do something with the packet
    });
  } else {
    System.out.println("Listen failed" + asyncResult.cause());
  }
});

Be aware that even if the {code AsyncResult} is successed it only means it might be written on the network stack, but gives no guarantee that it ever reached or will reach the remote peer at all.

If you need such a guarantee then you want to use TCP with some handshaking logic build on top.
Multicast
Sending Multicast packets

Multicast allows multiple sockets to receive the same packets. This works by have same join a multicast group to which you can send packets.

We will look at how you can joint a Multicast Group and so receive packets in the next section.

For now let us focus on how to send those. Sending multicast packets is not different to send normal Datagram Packets.

The only difference is that you would pass in a multicast group address to the send method.

This is show here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
Buffer buffer = Buffer.buffer("content");
// Send a Buffer to a multicast address
socket.send(buffer, 1234, "230.0.0.1", asyncResult -> {
  System.out.println("Send succeeded? " + asyncResult.succeeded());
});

All sockets that have joined the multicast group 230.0.0.1 will receive the packet.
Receiving Multicast packets

If you want to receive packets for specific Multicast group you need to bind the DatagramSocket by calling listen(…​) on it and join the Multicast group.

This way you will be able to receive DatagramPackets that were sent to the address and port on which the DatagramSocket listens and also to those sent to the Multicast group.

Beside this you also want to set a Handler which will be called for each received DatagramPacket.

The DatagramPacket has the following methods:

    sender(): The InetSocketAddress which represent the sender of the packet

    data(): The Buffer which holds the data which was received.

So to listen on a specific address and port and also receive packets for the Multicast group 230.0.0.1 you would do something like shown here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
socket.listen(1234, "0.0.0.0", asyncResult -> {
  if (asyncResult.succeeded()) {
    socket.handler(packet -> {
      // Do something with the packet
    });

    // join the multicast group
    socket.listenMulticastGroup("230.0.0.1", asyncResult2 -> {
        System.out.println("Listen succeeded? " + asyncResult2.succeeded());
    });
  } else {
    System.out.println("Listen failed" + asyncResult.cause());
  }
});

Unlisten / leave a Multicast group

There are sometimes situations where you want to receive packets for a Multicast group for a limited time.

In this situations you can first start to listen for them and then later unlisten.

This is shown here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());
socket.listen(1234, "0.0.0.0", asyncResult -> {
    if (asyncResult.succeeded()) {
      socket.handler(packet -> {
        // Do something with the packet
      });

      // join the multicast group
      socket.listenMulticastGroup("230.0.0.1", asyncResult2 -> {
          if (asyncResult2.succeeded()) {
            // will now receive packets for group

            // do some work

            socket.unlistenMulticastGroup("230.0.0.1", asyncResult3 -> {
              System.out.println("Unlisten succeeded? " + asyncResult3.succeeded());
            });
          } else {
            System.out.println("Listen failed" + asyncResult2.cause());
          }
      });
    } else {
      System.out.println("Listen failed" + asyncResult.cause());
    }
});

Blocking multicast

Beside unlisten a Multicast address it’s also possible to just block multicast for a specific sender address.

Be aware this only work on some Operating Systems and kernel versions. So please check the Operating System documentation if it’s supported.

This an expert feature.

To block multicast from a specific address you can call blockMulticastGroup(…​) on the DatagramSocket like shown here:

DatagramSocket socket = vertx.createDatagramSocket(new DatagramSocketOptions());

// Some code

// This would block packets which are send from 10.0.0.2
socket.blockMulticastGroup("230.0.0.1", "10.0.0.2", asyncResult -> {
  System.out.println("block succeeded? " + asyncResult.succeeded());
});

DatagramSocket properties

When creating a DatagramSocket there are multiple properties you can set to change it’s behaviour with the DatagramSocketOptions object. Those are listed here:

    setSendBufferSize Sets the send buffer size in bytes.

    setReceiveBufferSize Sets the TCP receive buffer size in bytes.

    setReuseAddress If true then addresses in TIME_WAIT state can be reused after they have been closed.

    setTrafficClass

    setBroadcast Sets or clears the SO_BROADCAST socket option. When this option is set, Datagram (UDP) packets may be sent to a local interface’s broadcast address.

    setMulticastNetworkInterface Sets or clears the IP_MULTICAST_LOOP socket option. When this option is set, multicast packets will also be received on the local interface.

    setMulticastTimeToLive Sets the IP_MULTICAST_TTL socket option. TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.

DatagramSocket Local Address

You can find out the local address of the socket (i.e. the address of this side of the UDP Socket) by calling localAddress. This will only return an InetSocketAddress if you bound the DatagramSocket with listen(…​) before, otherwise it will return null.
Closing a DatagramSocket

You can close a socket by invoking the close method. This will close the socket and release all resources
DNS client

Often you will find yourself in situations where you need to obtain DNS informations in an asynchronous fashion.

Unfortunally this is not possible with the API that is shipped with the Java Virtual Machine itself. Because of this Vert.x offers it’s own API for DNS resolution which is fully asynchronous.

To obtain a DnsClient instance you will create a new via the Vertx instance.

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");

Be aware that you can pass in a varargs of InetSocketAddress arguments to specifiy more then one DNS Server to try to query for DNS resolution. The DNS Servers will be queried in the same order as specified here. Where the next will be used once the first produce an error while be used.
lookup

Try to lookup the A (ipv4) or AAAA (ipv6) record for a given name. The first which is returned will be used, so it behaves the same way as you may be used from when using "nslookup" on your operation system.

To lookup the A / AAAA record for "vertx.io" you would typically use it like:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.lookup("vertx.io", ar -> {
  if (ar.succeeded()) {
    System.out.println(ar.result());
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

lookup4

Try to lookup the A (ipv4) record for a given name. The first which is returned will be used, so it behaves the same way as you may be used from when using "nslookup" on your operation system.

To lookup the A record for "vertx.io" you would typically use it like:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.lookup4("vertx.io", ar -> {
  if (ar.succeeded()) {
    System.out.println(ar.result());
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

lookup6

Try to lookup the AAAA (ipv6) record for a given name. The first which is returned will be used, so it behaves the same way as you may be used from when using "nslookup" on your operation system.

To lookup the A record for "vertx.io" you would typically use it like:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.lookup6("vertx.io", ar -> {
  if (ar.succeeded()) {
    System.out.println(ar.result());
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveA

Try to resolve all A (ipv4) records for a given name. This is quite similar to using "dig" on unix like operation systems.

To lookup all the A records for "vertx.io" you would typically do:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveA("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<String> records = ar.result();
    for (String record : records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveAAAA

Try to resolve all AAAA (ipv6) records for a given name. This is quite similar to using "dig" on unix like operation systems.

To lookup all the AAAAA records for "vertx.io" you would typically do:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveAAAA("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<String> records = ar.result();
    for (String record : records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveCNAME

Try to resolve all CNAME records for a given name. This is quite similar to using "dig" on unix like operation systems.

To lookup all the CNAME records for "vertx.io" you would typically do:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveCNAME("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<String> records = ar.result();
    for (String record : records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveMX

Try to resolve all MX records for a given name. The MX records are used to define which Mail-Server accepts emails for a given domain.

To lookup all the MX records for "vertx.io" you would typically do:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveMX("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<MxRecord> records = ar.result();
    for (MxRecord record: records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

Be aware that the List will contain the MxRecord sorted by the priority of them, which means MX records with smaller priority coming first in the List.

The MxRecord allows you to access the priority and the name of the MX record by offer methods for it like:

record.priority();
record.name();

resolveTXT

Try to resolve all TXT records for a given name. TXT records are often used to define extra informations for a domain.

To resolve all the TXT records for "vertx.io" you could use something along these lines:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveTXT("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<String> records = ar.result();
    for (String record: records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveNS

Try to resolve all NS records for a given name. The NS records specify which DNS Server hosts the DNS informations for a given domain.

To resolve all the NS records for "vertx.io" you could use something along these lines:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveNS("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<String> records = ar.result();
    for (String record: records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

resolveSRV

Try to resolve all SRV records for a given name. The SRV records are used to define extra informations like port and hostname of services. Some protocols need this extra informations.

To lookup all the SRV records for "vertx.io" you would typically do:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolveSRV("vertx.io", ar -> {
  if (ar.succeeded()) {
    List<SrvRecord> records = ar.result();
    for (SrvRecord record: records) {
      System.out.println(record);
    }
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

Be aware that the List will contain the SrvRecords sorted by the priority of them, which means SrvRecords with smaller priority coming first in the List.

The SrvRecord allows you to access all informations contained in the SRV record itself:

record.priority();
record.name();
record.weight();
record.port();
record.protocol();
record.service();
record.target();

Please refer to the API docs for the exact details.
resolvePTR

Try to resolve the PTR record for a given name. The PTR record maps an ipaddress to a name.

To resolve the PTR record for the ipaddress 10.0.0.1 you would use the PTR notion of "1.0.0.10.in-addr.arpa"

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.resolvePTR("1.0.0.10.in-addr.arpa", ar -> {
  if (ar.succeeded()) {
    String record = ar.result();
    System.out.println(record);
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

reverseLookup

Try to do a reverse lookup for an ipaddress. This is basically the same as resolve a PTR record, but allows you to just pass in the ipaddress and not a valid PTR query string.

To do a reverse lookup for the ipaddress 10.0.0.1 do something similar like this:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.reverseLookup("10.0.0.1", ar -> {
  if (ar.succeeded()) {
    String record = ar.result();
    System.out.println(record);
  } else {
    System.out.println("Failed to resolve entry" + ar.cause());
  }
});

Error handling

As you saw in previous sections the DnsClient allows you to pass in a Handler which will be notified with an AsyncResult once the query was complete.

In case of an error it will be notified with a DnsException which will hole a DnsResponseCode that indicate why the resolution failed. This DnsResponseCode can be used to inspect the cause in more detail.

Possible DnsResponseCodes are:

    NOERROR No record was found for a given query

    FORMERROR Format error

    SERVFAIL Server failure

    NXDOMAIN Name error

    NOTIMPL Not implemented by DNS Server

    REFUSED DNS Server refused the query

    YXDOMAIN Domain name should not exist

    YXRRSET Resource record should not exist

    NXRRSET RRSET does not exist

    NOTZONE Name not in zone

    BADVERS Bad extension mechanism for version

    BADSIG Bad signature

    BADKEY Bad key

    BADTIME Bad timestamp

All of those errors are "generated" by the DNS Server itself.

You can obtain the DnsResponseCode from the DnsException like:

DnsClient client = vertx.createDnsClient(53, "10.0.0.1");
client.lookup("nonexisting.vert.xio", ar -> {
  if (ar.succeeded()) {
    String record = ar.result();
    System.out.println(record);
  } else {
    Throwable cause = ar.cause();
    if (cause instanceof DnsException) {
      DnsException exception = (DnsException) cause;
      DnsResponseCode code = exception.code();
      // ...
    } else {
      System.out.println("Failed to resolve entry" + ar.cause());
    }
  }
});

Streams

There are several objects in Vert.x that allow items to be read from and written.

In previous versions the streams.adoc package was manipulating Buffer objects exclusively. From now, streams are not coupled to buffers anymore and they work with any kind of objects.

In Vert.x, write calls return immediately, and writes are queued internally.

It’s not hard to see that if you write to an object faster than it can actually write the data to its underlying resource, then the write queue can grow unbounded - eventually resulting in memory exhaustion.

To solve this problem a simple flow control (back-pressure) capability is provided by some objects in the Vert.x API.

Any flow control aware object that can be written-to implements WriteStream, while any flow control object that can be read-from is said to implement ReadStream.

Let’s take an example where we want to read from a ReadStream then write the data to a WriteStream.

A very simple example would be reading from a NetSocket then writing back to the same NetSocket - since NetSocket implements both ReadStream and WriteStream. Note that this works between any ReadStream and WriteStream compliant object, including HTTP requests, HTTP responses, async files I/O, WebSockets, etc.

A naive way to do this would be to directly take the data that has been read and immediately write it to the NetSocket:

NetServer server = vertx.createNetServer(
    new NetServerOptions().setPort(1234).setHost("localhost")
);
server.connectHandler(sock -> {
  sock.handler(buffer -> {
    // Write the data straight back
    sock.write(buffer);
  });
}).listen();

There is a problem with the example above: if data is read from the socket faster than it can be written back to the socket, it will build up in the write queue of the NetSocket, eventually running out of RAM. This might happen, for example if the client at the other end of the socket wasn’t reading fast enough, effectively putting back-pressure on the connection.

Since NetSocket implements WriteStream, we can check if the WriteStream is full before writing to it:

NetServer server = vertx.createNetServer(
    new NetServerOptions().setPort(1234).setHost("localhost")
);
server.connectHandler(sock -> {
  sock.handler(buffer -> {
    if (!sock.writeQueueFull()) {
      sock.write(buffer);
    }
  });

}).listen();

This example won’t run out of RAM but we’ll end up losing data if the write queue gets full. What we really want to do is pause the NetSocket when the write queue is full:

NetServer server = vertx.createNetServer(
    new NetServerOptions().setPort(1234).setHost("localhost")
);
server.connectHandler(sock -> {
  sock.handler(buffer -> {
    sock.write(buffer);
    if (sock.writeQueueFull()) {
      sock.pause();
    }
  });
}).listen();

We’re almost there, but not quite. The NetSocket now gets paused when the file is full, but we also need to unpause it when the write queue has processed its backlog:

NetServer server = vertx.createNetServer(
    new NetServerOptions().setPort(1234).setHost("localhost")
);
server.connectHandler(sock -> {
  sock.handler(buffer -> {
    sock.write(buffer);
    if (sock.writeQueueFull()) {
      sock.pause();
      sock.drainHandler(done -> {
        sock.resume();
      });
    }
  });
}).listen();

And there we have it. The drainHandler event handler will get called when the write queue is ready to accept more data, this resumes the NetSocket that allows more data to be read.

Wanting to do this is quite common while writing Vert.x applications, so we provide a helper class called Pump that does all of this hard work for you. You just feed it the ReadStream plus the WriteStream then start it:

NetServer server = vertx.createNetServer(
    new NetServerOptions().setPort(1234).setHost("localhost")
);
server.connectHandler(sock -> {
  Pump.pump(sock, sock).start();
}).listen();

This does exactly the same thing as the more verbose example.

Let’s now look at the methods on ReadStream and WriteStream in more detail:
ReadStream

ReadStream is implemented by HttpClientResponse, DatagramSocket, HttpClientRequest, HttpServerFileUpload, HttpServerRequest, HttpServerRequestStream, MessageConsumer, NetSocket, NetSocketStream, WebSocket, WebSocketStream, TimeoutStream, AsyncFile.

Functions:

    handler: set a handler which will receive items from the ReadStream.

    pause: pause the handler. When paused no items will be received in the handler.

    resume: resume the handler. The handler will be called if any item arrives.

    exceptionHandler: Will be called if an exception occurs on the ReadStream.

    endHandler: Will be called when end of stream is reached. This might be when EOF is reached if the ReadStream represents a file, or when end of request is reached if it’s an HTTP request, or when the connection is closed if it’s a TCP socket.

WriteStream

WriteStream is implemented by HttpClientRequest, HttpServerResponse WebSocket, NetSocket, AsyncFile, PacketWritestream and MessageProducer

Functions:

    write: write an object to the WriteStream. This method will never block. Writes are queued internally and asynchronously written to the underlying resource.

    setWriteQueueMaxSize: set the number of object at which the write queue is considered full, and the method writeQueueFull returns true. Note that, when the write queue is considered full, if write is called the data will still be accepted and queued. The actual number depends on the stream implementation, for Buffer the size represents the actual number of bytes written and not the number of buffers.

    writeQueueFull: returns true if the write queue is considered full.

    exceptionHandler: Will be called if an exception occurs on the WriteStream.

    drainHandler: The handler will be called if the WriteStream is considered no longer full.

Pump

Instances of Pump have the following methods:

    start: Start the pump.

    stop: Stops the pump. When the pump starts it is in stopped mode.

    setWriteQueueMaxSize: This has the same meaning as setWriteQueueMaxSize on the WriteStream.

A pump can be started and stopped multiple times.

When a pump is first created it is not started. You need to call the start() method to start it.
Record Parser

The record parser allows you to easily parse protocols which are delimited by a sequence of bytes, or fixed size records.

It transforms a sequence of input buffer to a sequence of buffer structured as configured (either fixed size or separated records).

For example, if you have a simple ASCII text protocol delimited by '\n' and the input is the following:

buffer1:HELLO\nHOW ARE Y
buffer2:OU?\nI AM
buffer3: DOING OK
buffer4:\n

The record parser would produce

buffer1:HELLO
buffer2:HOW ARE YOU?
buffer3:I AM DOING OK

Let’s see the associated code:

final RecordParser parser = RecordParser.newDelimited("\n", h -> {
  System.out.println(h.toString());
});

parser.handle(Buffer.buffer("HELLO\nHOW ARE Y"));
parser.handle(Buffer.buffer("OU?\nI AM"));
parser.handle(Buffer.buffer("DOING OK"));
parser.handle(Buffer.buffer("\n"));

You can also produce fixed sized chunks as follows:

RecordParser.newFixed(4, h -> {
  System.out.println(h.toString());
});

For more details, check out the RecordParser class.
Thread safety

Most Vert.x objects are safe to access from different threads. However performance is optimised when they are accessed from the same context they were created from.

For example if you have deployed a verticle which creates a NetServer which provides NetSocket instances in it’s handler, then it’s best to always access that socket instance from the event loop of the verticle.

If you stick to the standard Vert.x verticle deployment model and avoid sharing objects between verticles then this should be the case without you having to think about it.
Metrics SPI

By default Vert.x does not record any metrics. Instead it provides an SPI for others to implement which can be added to the classpath. The metrics SPI is an advanced feature which allows implementers to capture events from Vert.x in order to gather metrics. For more information on this, please consult the API Documentation.
OSGi

Vert.x Core is packaged as an OSGi bundle, so can be used in any OSGi R4.2+ environment such as Apache Felix or Eclipse Equinox. The bundle exports io.vertx.core*.

However, the bundle has some dependencies on Jackson and Netty. To get the vert.x core bundle resolved deploy:

    Jackson Annotation [2.6.0,3)

    Jackson Core [2.6.2,3)

    Jackson Databind [2.6.2,3)

    Netty Buffer [4.0.31,5)

    Netty Codec [4.0.31,5)

    Netty Codec/Socks [4.0.31,5)

    Netty Codec/Common [4.0.31,5)

    Netty Codec/Handler [4.0.31,5)

    Netty Codec/Transport [4.0.31,5)

Here is a working deployment on Apache Felix 5.2.0:

14|Active     |    1|Jackson-annotations (2.6.0)
15|Active     |    1|Jackson-core (2.6.2)
16|Active     |    1|jackson-databind (2.6.2)
18|Active     |    1|Netty/Buffer (4.0.31.Final)
19|Active     |    1|Netty/Codec (4.0.31.Final)
20|Active     |    1|Netty/Codec/HTTP (4.0.31.Final)
21|Active     |    1|Netty/Codec/Socks (4.0.31.Final)
22|Active     |    1|Netty/Common (4.0.31.Final)
23|Active     |    1|Netty/Handler (4.0.31.Final)
24|Active     |    1|Netty/Transport (4.0.31.Final)
25|Active     |    1|Netty/Transport/SCTP (4.0.31.Final)
26|Active     |    1|Vert.x Core (3.1.0)

On Equinox, you may want to disable the ContextFinder with the following framework property: eclipse.bundle.setTCCL=false






<hr/>

### 22.`vertx`命令行
`Vert.X`可以直接使用`vertx`命令来实现用户的基础交互，交互的主要用途是运行`Vert.X`中的`verticle`，交互之前需要使用`Vert.X`的二进制版本先配置和安装，并且将`bin`目录设置到`PATH`环境变量中，因为`Vert.X`用Java开发，所以还需要保证`JDK 8`的环境是安装好了的，`3.0`环境的最低JDK版本要求是`8.0`。<font style="color:red">【*：如果`Vert.X`使用的是其他语言开发那么`JDK`是非必须的，对于`Java`语言而言是必须的配置】</font>

#### 22.1.运行`Verticle`

看看下边的运行`Verticle`的命令：

	vertx run my-verticle.js                                 (1)
	vertx run my-verticle.groovy                             (2)
	vertx run my-verticle.rb                                 (3)

	vertx run io.vertx.example.MyVerticle                    (4)
	vertx run io.vertx.example.MVerticle -cp my-verticle.jar (5)

	vertx run MyVerticle.java                                (6)

1. 发布一个`JavaScript`版的`Verticle`；
2. 发布一个`Groovy`版的`Verticle`；
3. 发布一个`Ruby`版的`Verticle`；
4. 发布一个已经编译好的`Java`版的`Verticle`，`CLASSPATH`的根目录就是当前目录；
5. 发布一个打包成了`JAR`的`Verticle`，这个`JAR`文件必须在`CLASSPATH`中存在；
6. 直接编译`Java`源文件并且发布这个`Verticle`；

<font style="color:blue">如果使用的是`FQCN`的格式，则需要通过加前缀来标识使用的语言版本号，例如：</font>

	vertx run groovy:io.vertx.example.MyGroovyVerticle

**`vertx run`的可选参数**

* `-conf <config_file>`：配置文件路径，这个文件是一个`JSON`格式的配置文件；
* `-cp <path>`：路径用于查询`Verticle`需要使用到的所有的资源信息，包括类、资源文件、配置文件等。默认值是`.`【当前目录】，如果`Verticle`中引用了其他脚本、类、资源文件，则需要保证这些内容全部存在于这个目录中，`<path>`可以包含多个实体，使用`:`或`;`两个符号分割，每一个路径地址可以是一个绝对路径，也可以是一个相对路径，例如：

		-cp classes:lib/otherscripts:jars/myjar.jar:jars/otherjar.jar
<font style="color:red">通常不建议将资源文件放到`System`系统`CLASSPATH`中，一般是在这个参数中指明某个`Verticle`需要使用的`CLASSPATH`。</font>

* `-instances <instances>`：运行的`Verticle`的实例的数量，每一个`verticle`实例都是严格的单线程实例用于水平扩展，而这个参数指明了初始化的实例数量；
* `-worker`：标识当前这个`Verticle`是否以一个`Worker Verticle`运行；
* `-cluster`：默认是`false`的，标识当前`Verticle`可以按照`Cluster`的模式来运行，这个模式下的`Verticle`可支持分布式的`Event Bus`；
* `-cluster-port`：如果`-cluster`选项设置了过后，这个选项用于设置当前集群和其他`Vert.X`实例进行通讯，默认值为`0`表示使用空余的`port`执行通讯，除非使用特定的集群通讯端口，否则这个端口号一般不去进行手动设置；
* `-cluster-host`：如果`-cluster`选项进行设置过后，这个选项用于设置当前集群和其他`Vert.X`实例通讯的域名，默认会从合法的接口中读取对应的域名信息；
* `-ha`：用于设置`HA`架构下的`Vert.X`，实现高可用性；
* `-quorum`：用于和`-ha`实现组合配置，它表示了`HA`的发布中需要的节点最小数量，默认为`0`；
* `-hagroup`：用于和`-ha`实现组合配置，提供了节点需要加入的`HA`的组的名称，这个配置可以让一个`Vert.X`集群中支持多个`HA`组的架构，节点可以在同一个组类支持`Failover`机制，默认值为`__DEFAULT__`；

**运行例子**

1. 使用默认设置运行一个`JavaScript`的`Verticle`：

		vertx run server.js
2. 运行`10`个用Java语言预编译好的`Verticle`：

		vertx run com.acme.MyVerticle -cp "classes:lib/myjar.jar" -instances 10
3. 直接使用`Java`源代码文件运行`10`个实例：

		vertx run MyVerticle.java -instances 10
4. 运行`20`个用`Ruby`写好的`Worker Verticle`：

		vertx run order_worker.rb -instances 20 -worker
5. 在同一个机器上运行两个用`JavaScript`写好的`Verticle`组成一个集群

		vertx run handler.js -cluster
		vertx run sender.js -cluster
6. 运行带配置文件的`Ruby`写的`Verticle`

		vertx run my_verticle.rb -conf my_verticle.conf
`my_verticle.conf`文件的内容如下：

		{
			"name": "foo",
			"num_widgets": 46
		}
7. `HA`的架构支持空实例的运行，可直接使用下边命令运行空实例，然后在这个`HA`的组中添加新的节点：

		vertx -ha


#### 22.2.执行`Fat Jar`类型的`Verticle`【`Eclipse中的测试方式`】

一个`Fat Jar`是一个嵌入了依赖`Java`类的完整的Java版的`Verticle`，这种情况下则不需要安装`Vert.X`在机器上，其运行命令使用：

	java -jar my-verticle-fat.jar
一个`Fat Jar`必须包含下边内容：

* `Main-Class`设置为`io.vertx.core.Starter`
* `Main-Verticle`设置一个主运行的`Verticle`【使用类全名】

在运行的时候也可以将`vertx run`中的参数传入

	java -jar my-verticle-fat.jar -cluster -conf myconf.json
	java -jar my-verticle-fat.jar -cluster -conf myconf.json -cp path/to/dir/conf/cluster_xml

<font style="color:red">这种方式可以使用`Gradle`和`Maven`的插件实现打包。</font>

<hr/>

### 23.集群管理器【`Cluster Manager`】

在`Vert.X`中集群管理主要包含下边功能：

* 针对`Vert.X`集群中的节点进行自动发现以及分组功能；
* 维护一个集群中的广义`Topic`的订阅列表，因为集群中的`Event Bus`是分布式的；
* 分布式`Map`的支持
* 分布式`Lock`的支持
* 分布式`Counter`的支持

集群管理器并不负责`Event Bus`在节点之间的内部通讯，这个过程是直接让`Vert.X`中的`TCP`连接完成的，`Vert.X`分布式环境默认使用的集群管理器是`Hazelcast`，但是它支持可替换的插件结构，可根据自己的需要使用特定的集群管理器执行热部署以及热替换；

集群管理器必须实现`ClusterManager`接口，而`Vert.X`会在运行时通过`Java Service Loader`功能来查找实现了`ClusterManager`的集群管理器的实现类；

* 如果是从命令行运行了`Vert.X`，则需要保证在安装好的`Vert.X`的`lib`中包含集群管理器实现类打包好的`jar`，否则会找不到实现；
* 如果是直接使用`Maven`或`Gradle`项目来设置集群管理器则可以将它直接添加到起依赖项中去；
* 如果是嵌入式的方式集成`Vert.X`，则可以在编程过程中调用`setClusterManager`方法；

<hr/>

### 24.日志

`Vert.X`中的日志使用了内置的日志`API`，它默认实现使用的是`JDK`中自带的日志功能：`JUL`。

**配置`JUL`**

设置系统属性：`java.util.logging.config.file`

`Vert.X`同样提供了属性文件：`vertx-default-jul-logging.properties`来针对日志其进行配置；

**日志框架**

设置系统属性：`vertx.logger-delegate-factory-class-name`，设置实现了`LoggerFactory`接口的日志实现类，实际上`Vert.X`提供了两种默认实现：

* Log4J：`io.vertx.core.logging.Log4jLogDelegateFactory`
* SLF4J：`io.vertx.core.logging.SLF4JLogDelegateFactory`

**应用中直接调用**

<font style="color:red">直接在应用代码中写，这个不做介绍，和Prayer底层的日志结构是一致的。</font>

<hr/>

### 25.HA和Fail-Over

`Vert.X`支持高可用架构，这种情况下需要在`Verticle`运行的时候进行一定的设置，而且`Vert.X`的实例必须在同一个集群中；

**Automatic failover**

当`Vert.X`使用了`HA`方式运行时，如果一旦其中某一个`Verticle`的实例运行失败或者死亡，则`Verticle`会自动在另外一个`Vert.X`实例中进行重发布，这个过程称为`Verticle Fail-Over`，其运行命令为：

	vertx run my-verticle.js -ha

如果需要在另外一个`Vert.X`中运行一个新的`Verticle`，则使用：

	vertx run my-other-verticle.js -ha
<font style="color:red">这样同一个`Cluster`中就运行了两个`Verticle`！</font>

如果`Vert.X`实例运行在`my-verticle.js`中，而且现在死亡了，则运行在`my-other-verticle.js`中的`Vert.X`会自动重新发布`my-verticle.js`，到最后这个`Vert.X`的实例会运行两个`Verticle`；触发`Fail-Over`的方式是使用`CTRL-C`或`kill -SIGINT`来关闭以及清除某个运行的`Vert.X`实例。

**HA Group**

默认使用的`HA`组是`__DEFAULT__`，如果需要设置一个自定义的`HA`组，则需要使用：

	vertx run my-verticle.js -ha -ha-group my-group

看看下边的例子：

1. 在`g1`中运行一个`Verticle`

		vertx run my-verticle.js -ha -hagroup g1
2. 在`g1`中运行另外一个`Verticle`

		vertx run my-other-verticle.js -ha -hagroup g1
3. 在`g2`中运行第三个`Verticle`

		vertx run yet-another-verticle.js -ha -hagroup g2
这种情况下如果Kill掉第三个，则`Fail-Over`不会被触发，因为第三个`Verticle`和前两个不在同一个`HA`的组中。

<font style="color:red">省略话题：`Dealing with Network Partitions - Quora`</font>

<hr/>








Security notes

Vert.x is a toolkit, not an opinionated framework where we force you to do things in a certain way. This gives you great power as a developer but with that comes great responsibility.

As with any toolkit, it’s possible to write insecure applications, so you should always be careful when developing your application especially if it’s exposed to the public (e.g. over the internet).
Web applications

If writing a web application it’s highly recommended that you use Vert.x-Web instead of Vert.x core directly for serving resources and handling file uploads.

Vert.x-Web normalises the path in requests to prevent malicious clients from crafting URLs to access resources outside of the web root.

Similarly for file uploads Vert.x-Web provides functionality for uploading to a known place on disk and does not rely on the filename provided by the client in the upload which could be crafted to upload to a different place on disk.

Vert.x core itself does not provide such checks so it would be up to you as a developer to implement them yourself.
Clustered event bus traffic

When clustering the event bus between different Vert.x nodes on a network, the traffic is sent un-encrypted across the wire, so do not use this if you have confidential data to send and your Vert.x nodes are not on a trusted network.
Standard security best practices

Any service can have potentially vulnerabilities whether it’s written using Vert.x or any other toolkit so always follow security best practice, especially if your service is public facing.

For example you should always run them in a DMZ and with an user account that has limited rights in order to limit the extent of damage in case the service was compromised.
Vert.x Command Line Interface API

Vert.x Core provides an API for parsing command line arguments passed to programs.

It’s also able to print help messages detailing the options available for a command line tool. Even if such features are far from the Vert.x core topics, this API is used in the Launcher class that you can use in fat-jar and in the vertx command line tools. In addition, it’s polyglot (can be used from any supported language) and is used in Vert.x Shell.

Vert.x CLI provides a model to describe your command line interface, but also a parser. This parser supports different types of syntax:

    POSIX like options (ie. tar -zxvf foo.tar.gz)

    GNU like long options (ie. du --human-readable --max-depth=1)

    Java like properties (ie. java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo)

    Short options with value attached (ie. gcc -O2 foo.c)

    Long options with single hyphen (ie. ant -projecthelp)

Using the CLI api is a 3-steps process:

    The definition of the command line interface

    The parsing of the user command line

    The query / interrogation

Definition Stage

Each command line interface must define the set of options and arguments that will be used. It also requires a name. The CLI API uses the Option and Argument classes to describe options and arguments:

CLI cli = CLI.create("copy")
    .setSummary("A command line interface to copy files.")
    .addOption(new Option()
        .setLongName("directory")
        .setShortName("R")
        .setDescription("enables directory support")
        .setFlag(true))
    .addArgument(new Argument()
        .setIndex(0)
        .setDescription("The source")
        .setArgName("source"))
    .addArgument(new Argument()
        .setIndex(0)
        .setDescription("The destination")
        .setArgName("target"));

As you can see, you can create a new CLI using CLI.create. The passed string is the name of the CLI. Once created you can set the summary and description. The summary is intended to be short (one line), while the description can contain more details. Each option and argument are also added on the CLI object using the addArgument and addOption methods.
Options

An Option is a command line parameter identified by a key present in the user command line. Options must have at least a long name or a short name. Long name are generally used using a -- prefix, while short names are used with a single -. Options can get a description displayed in the usage (see below). Options can receive 0, 1 or several values. An option receiving 0 values is a flag, and must be declared using setFlag. By default, options receive a single value, however, you can configure the option to receive several values using setMultiValued:

CLI cli = CLI.create("some-name")
    .setSummary("A command line interface illustrating the options valuation.")
    .addOption(new Option()
        .setLongName("flag").setShortName("f").setFlag(true).setDescription("a flag"))
    .addOption(new Option()
        .setLongName("single").setShortName("s").setDescription("a single-valued option"))
    .addOption(new Option()
        .setLongName("multiple").setShortName("m").setMultiValued(true)
        .setDescription("a multi-valued option"));

Options can be marked as mandatory. A mandatory option not set in the user command line throws an exception during the parsing:

CLI cli = CLI.create("some-name")
    .addOption(new Option()
        .setLongName("mandatory")
        .setRequired(true)
        .setDescription("a mandatory option"));

Non-mandatory options can have a default value. This value would be used if the user does not set the option in the command line:

CLI cli = CLI.create("some-name")
    .addOption(new Option()
        .setLongName("optional")
        .setDefaultValue("hello")
        .setDescription("an optional option with a default value"));

An option can be hidden using the setHidden method. Hidden option are not listed in the usage, but can still be used in the user command line (for power-users).

If the option value is contrained to a fixed set, you can set the different acceptable choices:

CLI cli = CLI.create("some-name")
    .addOption(new Option()
        .setLongName("color")
        .setDefaultValue("green")
        .addChoice("blue").addChoice("red").addChoice("green")
        .setDescription("a color"));

Options can also be instantiated from their JSON form.
Arguments

Unlike options, arguments do not have a key and are identified by their index. For example, in java com.acme.Foo, com.acme.Foo is an argument.

Arguments do not have a name, there are identified using a 0-based index. The first parameter has the index 0:

CLI cli = CLI.create("some-name")
    .addArgument(new Argument()
        .setIndex(0)
        .setDescription("the first argument")
        .setArgName("arg1"))
    .addArgument(new Argument()
        .setIndex(1)
        .setDescription("the second argument")
        .setArgName("arg2"));

If you don’t set the argument indexes, it computes it automatically by using the declaration order.

CLI cli = CLI.create("some-name")
    // will have the index 0
    .addArgument(new Argument()
        .setDescription("the first argument")
        .setArgName("arg1"))
    // will have the index 1
    .addArgument(new Argument()
        .setDescription("the second argument")
        .setArgName("arg2"));

The argName is optional and used in the usage message.

As options, Argument can:

    be hidden using setHidden

    be mandatory using setRequired

    have a default value using setDefaultValue

    receive several values using setMultiValued - only the last argument can be multi-valued.

Arguments can also be instantiated from their JSON form.
Usage generation

Once your CLI instance is configured, you can generate the usage message:

CLI cli = CLI.create("copy")
    .setSummary("A command line interface to copy files.")
    .addOption(new Option()
        .setLongName("directory")
        .setShortName("R")
        .setDescription("enables directory support")
        .setFlag(true))
    .addArgument(new Argument()
        .setIndex(0)
        .setDescription("The source")
        .setArgName("source"))
    .addArgument(new Argument()
        .setIndex(0)
        .setDescription("The destination")
        .setArgName("target"));

StringBuilder builder = new StringBuilder();
cli.usage(builder);

It generates an usage message like this one:

Usage: copy [-R] source target

A command line interface to copy files.

  -R,--directory   enables directory support

If you need to tune the usage message, check the UsageMessageFormatter class.
Parsing Stage

Once your CLI instance is configured, you can parse the user command line to evaluate each option and argument:

CommandLine commandLine = cli.parse(userCommandLineArguments);

The parse method returns a CommandLine object containing the values. By default, it validates the user command line and checks that each mandatory options and arguments have been set as well as the number of values received by each option. You can disable the validation by passing false as second parameter of parse. This is useful if you want to check an argument or option is present even if the parsed command line is invalid.

You can check whether or not the CommandLine is valid using isValid.
Query / Interrogation Stage

Once parsed, you can retrieve the values of the options and arguments from the CommandLine object returned by the parse method:

CommandLine commandLine = cli.parse(userCommandLineArguments);
String opt = commandLine.getOptionValue("my-option");
boolean flag = commandLine.isFlagEnabled("my-flag");
String arg0 = commandLine.getArgumentValue(0);

One of your option can have been marked as "help". If a user command line enabled a "help" option, the validation won’t failed, but give you the opportunity to check if the user asks for help:

CLI cli = CLI.create("test")
    .addOption(
        new Option().setLongName("help").setShortName("h").setFlag(true).setHelp(true))
    .addOption(
        new Option().setLongName("mandatory").setRequired(true));

CommandLine line = cli.parse(Collections.singletonList("-h"));

// The parsing does not fail and let you do:
if (!line.isValid() && line.isAskingForHelp()) {
  StringBuilder builder = new StringBuilder();
  cli.usage(builder);
  stream.print(builder.toString());
}

Typed options and arguments

The described Option and Argument classes are untyped, meaning that the only get String values.

TypedOption and TypedArgument let you specify a type, so the (String) raw value is converted to the specified type.

Instead of Option and Argument, use TypedOption and TypedArgument in the CLI definition:

CLI cli = CLI.create("copy")
    .setSummary("A command line interface to copy files.")
    .addOption(new TypedOption<Boolean>()
        .setType(Boolean.class)
        .setLongName("directory")
        .setShortName("R")
        .setDescription("enables directory support")
        .setFlag(true))
    .addArgument(new TypedArgument<File>()
        .setType(File.class)
        .setIndex(0)
        .setDescription("The source")
        .setArgName("source"))
    .addArgument(new TypedArgument<File>()
        .setType(File.class)
        .setIndex(0)
        .setDescription("The destination")
        .setArgName("target"));

Then you can retrieve the converted values as follows:

CommandLine commandLine = cli.parse(userCommandLineArguments);
boolean flag = commandLine.getOptionValue("R");
File source = commandLine.getArgumentValue("source");
File target = commandLine.getArgumentValue("target");

The vert.x CLI is able to convert to classes:

    having a constructor with a single String argument, such as File or JsonObject

    with a static from or fromString method

    with a static valueOf method, such as primitive types and enumeration

In addition, you can implement your own Converter and instruct the CLI to use this converter:

CLI cli = CLI.create("some-name")
    .addOption(new TypedOption<Person>()
        .setType(Person.class)
        .setConverter(new PersonConverter())
        .setLongName("person"));

For booleans, the boolean values are evaluated to true: on, yes, 1, true.

If one of your option as an enum as type, it computes the set of choices automatically.
Using annotations

You can also define your CLI using annotations. Definition is done using annotation on the class and on setter methods:

@Name("some-name")
@Summary("some short summary.")
@Description("some long description")
public class AnnotatedCli {

  private boolean flag;
  private String name;
  private String arg;

 @Option(shortName = "f", flag = true)
 public void setFlag(boolean flag) {
   this.flag = flag;
 }

 @Option(longName = "name")
 public void setName(String name) {
   this.name = name;
 }

 @Argument(index = 0)
 public void setArg(String arg) {
  this.arg = arg;
 }
}

Once annotated, you can define the CLI and inject the values using:

CLI cli = CLI.create(AnnotatedCli.class);
CommandLine commandLine = cli.parse(userCommandLineArguments);
AnnotatedCli instance = new AnnotatedCli();
CLIConfigurator.inject(commandLine, instance);

The vert.x Launcher

The vert.x Launcher is used in fat jar as main class, and by the vertx command line utility. It executes a set of commands such as run, bare, start…​
Extending the vert.x Launcher

You can extend the set of command by implementing your own Command (in Java only):

@Name("my-command")
@Summary("A simple hello command.")
public class MyCommand extends DefaultCommand {

  private String name;

  @Option(longName = "name", required = true)
  public void setName(String n) {
    this.name = n;
  }

  @Override
  public void run() throws CLIException {
    System.out.println("Hello " + name);
  }
}

You also need an implementation of CommandFactory:

public class HelloCommandFactory extends DefaultCommandFactory<HelloCommand> {
  public HelloCommandFactory() {
   super(HelloCommand.class);
  }
}

Then, create the src/main/resources/META-INF/services/io.vertx.core.spi.launcher.CommandFactory and add a line indicating the fully qualified name of the factory:

io.vertx.core.launcher.example.HelloCommandFactory

Builds the jar containing the command. Be sure to includes the SPI file (META-INF/services/io.vertx.core.spi.launcher.CommandFactory).

Then, place the jar containing the command into the classpath of your fat-jar (or include it inside) or in the lib directory of your vert.x distribution, and you would be able to execute:

vertx hello vert.x
java -jar my-fat-jar.jar hello vert.x

Using the Launcher in fat jars

To use the Launcher class in a fat-jar just set the Main-Class of the MANIFEST to io.vertx.core.Launcher. In addition, set the Main-Verticle MANIFEST entry to the name of your main verticle.

By default, it executed the run command. However, you can configure the default command by setting the Main-Command MANIFEST entry. The default command is used if the fat jar is launched without a command.
Sub-classing the Launcher

You can also create a sub-class of Launcher to start your application. The class has been designed to be easily extensible.

A Launcher sub-class can:

    customize the vert.x configuration in beforeStartingVertx

    retrieve the vert.x instance created by the "run" or "bare" command by overriding afterStartingVertx

    configure the default verticle and command with getMainVerticle and getDefaultCommand

    add / remove commands using register and unregister






